{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Worldpay Within\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \nWhat it is\n\n    \nWorldpay Within is an embeddable payments agent that can be 'plugged' into an app or smart device. It lets you discover other devices and pay for that device's service(s). We've got the SDK in five languages: \nPython\n, \n.NET\n, \nNode.js\n, \nJava\n and \nGo\n.\n\n    \nWatch the demo\n\n  \n\n\n\n\n\n\n  \n\n     \n\n  \n\n  \n\n    \nWhy use it\n\n    \nYou can make or take payments from an IoT device. Maybe your car is running out of fuel and it broadcasts a need for petrol; perhaps you're a petrol station that has a service to offer.\n\n    \nFind out more\n\n\n  \n\n\n\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \nHow it works\n\n    \nThere are four simple interactions that take place with Worldpay Within: \nDiscover\n, \nSelect\n, \nPay\n and \nRelease\n.\n\n    \nFind out more\n\n  \n\n\n\n\n\n\n  \n\n    \nA demonstration\n\n    \n  \n\n  \n\n  \n\n    \n\n  \n\n\n\n\n\nWhat it is\n\n\nDriven by the \nInternet of Things\n (IoT), Worldpay is keen to demonstrate how you can integrate payments into everyday objects. So we created Worldpay Within.\n\n\nWe\u2019ve got a series of \nopen source\n software development kits (SDKs) that let you make and accept payments from a range of devices. We\u2019ve got SDKs for \nNode.js\n, \nPython\n, \nJava\n, \n.NET\n and \nGo\n. You can download these SDKs, get playing, configure your setup, and recommend changes to our open source libraries.\n\n\n Why use it\n\n\nYou might want to use Worldpay Within if you\u2019re a startup company that\u2019s creating technologies relating to the Internet of Things. Or perhaps you\u2019re a hobby developer who likes creating innovative technologies in your spare time.\n\n\nWorldpay Within provides you with the functionality and the SDKs to explore how the Internet of Things allows you to test the interaction between two devices and see how devices can make and receive payments.\n\n\n How it works\n\n\nThere are four simple interactions that take place with Worldpay Within: \nDiscover\n, \nSelect\n, \nPay\n and \nRelease\n.\n\n\nImagine that a car needs some fuel. It stops by a petrol station and broadcasts that it needs fuel. The petrol station receives this signal, informs the car of how much fuel costs and what options are available, and once the shopper has made a choice, Worldpay will process the payment and inform the petrol station that it can fuel the car.\n\n\n\n\nA demonstration of how to use Worldpay Within in four easy interactions\n\n\n\n\nDiscover\n - \nThing A (shopper)\n broadcasts to \nThing B (merchant)\n that it requires something.\n\n\nSelect\n - When \nThing B\n receives \nThing A\u2019s\n broadcast, it presents the options and the shopper chooses one.\n\n\nPay\n - \nThing A\n pays.\n\n\nRelease\n - Worldpay sends \nThing B\n a secure token (a trusted trigger) to release the service to \nThing A.\n\n\n\n\n The Internet of Things\n\n\nThe Internet of Things (IoT) is an initiative to connect everyday items to the internet. It could be a car which needs to pay for fuel or some repairs, or a fridge which needs to order some groceries.\n\n\nIt is estimated\n that there will be 6 billion devices connected to the IoT by the end of 2016 and 20 billion by 2020. Some of these devices will consume services from other devices for which a payment will be required.\n\n\nBy using a set of APIs, \u201cThing\u201d developers will be able to integrate Worldpay Within into their IoT device, enabling the \u201cThing\u201d to make and/or receive payments for services to and from other \u201cThings\u201d.\n\n\nWorldpay Within orchestrates smart things talking to each other and paying for services.\n\n\nHackathons\n\n\nIn 2016, Worldpay hosted the \nPayments \n IOT Hackathon\n in which we wanted to take digital payments to the next level. In 2017, we're hosting another Hackathon in Romania, in which we release Worldpay Within.\n\n\nWant to find out more? Head over to the \nHackathons\n page.\n\n\n It's open source\n\n\nWorldpay Within is open source, so why not give it a go yourself? You can find the GitHub library \nhere\n.\n\n\nIt's still an alpha-based experiment, but we're actively building new features (and bug fixes) and are concurrently working on evolving the security architecture so we can take real payments.\n\n\nWe'd love to see what you can come up with, so why not become a contributor? Head over to the \nIssues page\n to see how you can help. \n\n\nGet the SDKs\n\n\nWorldpay Within's SDK is written in GoLang and runs on smart devices, including Raspberry Pi. It lets you make and receive payments within the IoT. You can download the SDK in any of these languages and begin testing:\n\n\n  \nNode.js\n\n  \nPython\n\n  \nJava\n\n  \n.NET\n\n  \nGo\n\n\n\n\nContact us\n\n\nIf you've got any questions, or if you want to find out more, why not give us a shout at \n.\nYou can also contribute to our \nGitHub repository\n by \nlooking at our issues\n or becoming a contributor.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-worldpay-within", 
            "text": "", 
            "title": "Welcome to Worldpay Within"
        }, 
        {
            "location": "/#what-it-is", 
            "text": "Driven by the  Internet of Things  (IoT), Worldpay is keen to demonstrate how you can integrate payments into everyday objects. So we created Worldpay Within.  We\u2019ve got a series of  open source  software development kits (SDKs) that let you make and accept payments from a range of devices. We\u2019ve got SDKs for  Node.js ,  Python ,  Java ,  .NET  and  Go . You can download these SDKs, get playing, configure your setup, and recommend changes to our open source libraries.", 
            "title": "What it is"
        }, 
        {
            "location": "/#hackathons", 
            "text": "In 2016, Worldpay hosted the  Payments   IOT Hackathon  in which we wanted to take digital payments to the next level. In 2017, we're hosting another Hackathon in Romania, in which we release Worldpay Within.  Want to find out more? Head over to the  Hackathons  page.", 
            "title": "Hackathons"
        }, 
        {
            "location": "/#get-the-sdks", 
            "text": "Worldpay Within's SDK is written in GoLang and runs on smart devices, including Raspberry Pi. It lets you make and receive payments within the IoT. You can download the SDK in any of these languages and begin testing: \n   Node.js \n   Python \n   Java \n   .NET \n   Go", 
            "title": "Get the SDKs"
        }, 
        {
            "location": "/#contact-us", 
            "text": "If you've got any questions, or if you want to find out more, why not give us a shout at  .\nYou can also contribute to our  GitHub repository  by  looking at our issues  or becoming a contributor.", 
            "title": "Contact us"
        }, 
        {
            "location": "/get-started/", 
            "text": "New to Worldpay Within\n\n\nIf you're new to Worldpay Within, you can download the SDK in any of these languages and begin testing:\n\n\n  \nNode.js\n\n  \nPython\n\n  \nJava\n\n  \n.NET\n\n  \nGo\n\n\n\n\nAn experienced user\n\n\nIf you're familiar with how Worldpay Within works, and have used the SDKs before, you can find out more in our Advanced section:\n\n\n\n\nHow it works\n\n\nArchitecture\n\n\nInternal structure\n\n\nSample service messaging\n\n\nAPI Specification\n\n\n\n\nUseful terms\n\n\nThere's quite a few terms we're using in these SDKs and the rest of our documentation, so it's worth knowing what they are and what they mean.\n\n\n\n\n\n\n\n\nTerm\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\nAPI\n\n\nApplication Programming Interface\n\n\n\n\n\n\nWorldpay\n\n\nWorldpay Online Payment API, \nhttps://online.worldpay.com/\n\n\n\n\n\n\nHCE\n\n\nHost Card Emulation\n\n\n\n\n\n\nHTE\n\n\nHost Terminal Emulation\n\n\n\n\n\n\nHTTPS\n\n\nHyperText Transfer Protocol Secure\n\n\n\n\n\n\nIoT\n\n\nInternet of Things\n\n\n\n\n\n\nP2PE\n\n\nPoint to Point Encryption\n\n\n\n\n\n\nTLS\n\n\nTransport Layer Security\n\n\n\n\n\n\nUUID\n\n\nUniversally Unique Identifier\n\n\n\n\n\n\nRPC\n\n\nRemote Procedure Call", 
            "title": "Get started"
        }, 
        {
            "location": "/get-started/#new-to-worldpay-within", 
            "text": "If you're new to Worldpay Within, you can download the SDK in any of these languages and begin testing: \n   Node.js \n   Python \n   Java \n   .NET \n   Go", 
            "title": "New to Worldpay Within"
        }, 
        {
            "location": "/get-started/#an-experienced-user", 
            "text": "If you're familiar with how Worldpay Within works, and have used the SDKs before, you can find out more in our Advanced section:   How it works  Architecture  Internal structure  Sample service messaging  API Specification", 
            "title": "An experienced user"
        }, 
        {
            "location": "/get-started/#useful-terms", 
            "text": "There's quite a few terms we're using in these SDKs and the rest of our documentation, so it's worth knowing what they are and what they mean.     Term  Definition      API  Application Programming Interface    Worldpay  Worldpay Online Payment API,  https://online.worldpay.com/    HCE  Host Card Emulation    HTE  Host Terminal Emulation    HTTPS  HyperText Transfer Protocol Secure    IoT  Internet of Things    P2PE  Point to Point Encryption    TLS  Transport Layer Security    UUID  Universally Unique Identifier    RPC  Remote Procedure Call", 
            "title": "Useful terms"
        }, 
        {
            "location": "/nodejs/", 
            "text": "The Node.js implementation for the Worldpay Within IoT payment SDK. This SDK enables smart devices to discover each other, negotiate a price for services, make a payment (through Worldpay) for services, and then consume services via a \ntrusted trigger\n. For more information, see \nHome\n.\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have \nNode.js\n installed on your system. We've tested this wrapper with version 6.11.1.\n\n\nYou should also have \nnpm\n installed on your machine too.\n\n\nYou should create an account with \nWorldpay Online\n so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK. \n\n\n\n\n\n\nWarning\n\n\nMake sure you only use test API keys.\n\n\n\n\nGet started\n\n\nOnce you've got Node.js and npm.js, you should be good to go.\n\n\n\n\nClone or download \nthe repository\n.\n\n\nChange to the folder \ncd wpw-sdk-nodejs\n (if using linux / unix).\n\n\nRun the following command: \nnpm install thrift sleep\n.  \n\n\n\n\n\n\nNote\n\n\nIf you are using a different package manager than npm, please adjust the command accordingly.\n\n(If there are issues about access rights, add \nsudo\n in front of the above command)\n\n\n\n\nRun the examples\n\n\nOnce you've got the repository and have changed to the right folder, you can start testing to see if it works. We'd recommend using your own test API keys for this. We've left our ones in the code, but you won't be able to see the payments with our keys.\n\n\n\n\nIn one terminal/cmd (or on one device) run: \nnode example-producer-callbacks.js\n.\n\n    (You can run \nnode example-producer.js\n but this does not recall the producer, once it times out)\n\n\nIn another terminal/cmd, (or on another device, on the same network) run: \nnode example-consumer.js\n.\n\n\nA payment should happen. If you see the \nserviceDeliveryToken\n returned within the producer terminal/cmd, you will know that the payment was complete.\n\n\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nYou'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\n\n\nIf you've used Worldpay's own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nGot to \nSettings \n API keys\n and get your test keys.\n\n\nReplace the keys in the producer files.\n\n\nRe-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\n\n\nDebugging\n\n\nIf you get some odd error messages talking about a rpc-agent:\n\n\n\n\nTry typing the following command: \nps -e | grep rpc\n to get the pid(s) of rpc-agents that are running.\n\n\nThen do \nkill \npid\n, such as \nkill 13249234\n to kill these processes.\n\n\nTry re-running the examples.\n\n\n\n\nIf you're still having trouble, you can contact us at \n. Alternatively, you can \nraise an issue in GitHub\n.\n\n\nSo what's happening?\n\n\n\n\nThe Worldpay Within Flows sequence diagram\n\n\nYou can see there are four phases; \nDiscover\n, \nSelect\n, \nPay\n, and \nRelease\n. For more information, see \nHome\n.\n\n\nWhat IoT devices can I run this on?\n\n\n\n\nNote\n\n\nThe devices need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...\n\n\n\n\nWant to contribute?\n\n\nIf you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the \nInternal Structure of Worldpay Within\n and \nSample Service Messaging\n pages if you want to learn more about how Worldpay Within works.\n\n\nYou can also \nraise an issue in GitHub\n, or contact us directly at \n.", 
            "title": "Node.js"
        }, 
        {
            "location": "/nodejs/#prerequisites", 
            "text": "Before you get started, you should have  Node.js  installed on your system. We've tested this wrapper with version 6.11.1.  You should also have  npm  installed on your machine too.  You should create an account with  Worldpay Online  so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.     Warning  Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/nodejs/#get-started", 
            "text": "Once you've got Node.js and npm.js, you should be good to go.   Clone or download  the repository .  Change to the folder  cd wpw-sdk-nodejs  (if using linux / unix).  Run the following command:  npm install thrift sleep .      Note  If you are using a different package manager than npm, please adjust the command accordingly. \n(If there are issues about access rights, add  sudo  in front of the above command)", 
            "title": "Get started"
        }, 
        {
            "location": "/nodejs/#run-the-examples", 
            "text": "Once you've got the repository and have changed to the right folder, you can start testing to see if it works. We'd recommend using your own test API keys for this. We've left our ones in the code, but you won't be able to see the payments with our keys.   In one terminal/cmd (or on one device) run:  node example-producer-callbacks.js . \n    (You can run  node example-producer.js  but this does not recall the producer, once it times out)  In another terminal/cmd, (or on another device, on the same network) run:  node example-consumer.js .  A payment should happen. If you see the  serviceDeliveryToken  returned within the producer terminal/cmd, you will know that the payment was complete.", 
            "title": "Run the examples"
        }, 
        {
            "location": "/nodejs/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.", 
            "title": "See the payments"
        }, 
        {
            "location": "/nodejs/#if-you-used-your-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .", 
            "title": "If you used your own test API keys"
        }, 
        {
            "location": "/nodejs/#if-youve-used-worldpays-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  Got to  Settings   API keys  and get your test keys.  Replace the keys in the producer files.  Re-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "If you've used Worldpay's own test API keys"
        }, 
        {
            "location": "/nodejs/#debugging", 
            "text": "If you get some odd error messages talking about a rpc-agent:   Try typing the following command:  ps -e | grep rpc  to get the pid(s) of rpc-agents that are running.  Then do  kill  pid , such as  kill 13249234  to kill these processes.  Try re-running the examples.   If you're still having trouble, you can contact us at  . Alternatively, you can  raise an issue in GitHub .", 
            "title": "Debugging"
        }, 
        {
            "location": "/nodejs/#so-whats-happening", 
            "text": "The Worldpay Within Flows sequence diagram  You can see there are four phases;  Discover ,  Select ,  Pay , and  Release . For more information, see  Home .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/nodejs/#what-iot-devices-can-i-run-this-on", 
            "text": "Note  The devices need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...", 
            "title": "What IoT devices can I run this on?"
        }, 
        {
            "location": "/nodejs/#want-to-contribute", 
            "text": "If you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the  Internal Structure of Worldpay Within  and  Sample Service Messaging  pages if you want to learn more about how Worldpay Within works.  You can also  raise an issue in GitHub , or contact us directly at  .", 
            "title": "Want to contribute?"
        }, 
        {
            "location": "/python27/", 
            "text": "The Python implementation for the Worldpay Within IoT payment SDK. This SDK enables smart devices to discover each other, negotiate a price for services, make a payment (through Worldpay) for services, and then consume services via a \ntrusted trigger\n. For more information, see \nHome\n.\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have Python installed on your system. We've built the SDK to work with version 2.7 and 3.\n\n\nYou should create an account with \nWorldpay Online\n so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.\n\n\n\n\n\n\nWarning\n\n\nMake sure you only use test API keys.\n\n\n\n\nGet started\n\n\n\n\nDownload the \nrepository\n.\n\n\nDownload the latest version of Apache Thrift (currently 0.10.0).\n\n\nExtract the repository and change to the \nlib/py/\n directory.\n\n\nRun the following command: \nsudo python setup.py\n install.\n\n\n\n\nRun the examples\n\n\nYou can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.\n\n\n\n\nIn the first window, run \npython runConsumerOWP.py\n.\n\n\nIn the second window, run \npython runProducerOWP.py\n OR \npython runProducerCallbacksOWP.py\n.\n\n\nThe two smart devices should communicate with each other and make a payment.\n\n\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nYou'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\n\n\nIf you've used Worldpay's own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nGot to \nSettings \n API keys\n and get your test keys.\n\n\nReplace the keys in the producer python files.\n\n\nRe-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\n\n\nDebugging\n\n\nIf you get some odd error messages talking about a rpc-agent:\n\n\n\n\nTry typing the following command: \nps -e | grep rpc\n to get the pid(s) of rpc-agents that are running.\n\n\nThen do \nkill \npid\n, such as \nkill 13249234\n to kill these processes.\n\n\nTry re-running the examples.\n\n\n\n\nIf you're still having trouble, you can contact us at \n. Alternatively, you can \nraise an issue in GitHub\n.\n\n\nSo what's happening?\n\n\n\n\nThe Worldpay Within Flows sequence diagram\n\n\nYou can see there are four phases; \nDiscover\n, \nSelect\n, \nPay\n, and \nRelease\n. For more information, see \nWorldpay Within\n.\n\n\nWhat IoT devices can I run this on?\n\n\n\n\nNote\n\n\nThe devices need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...\n\n\n\n\nWant to contribute?\n\n\nIf you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the \nInternal Structure of Worldpay Within\n and \nSample Service Messaging\n pages if you want to learn more about how Worldpay Within works.\n\n\nYou can also \nraise an issue in GitHub\n, or contact us directly at \n.", 
            "title": "Python"
        }, 
        {
            "location": "/python27/#prerequisites", 
            "text": "Before you get started, you should have Python installed on your system. We've built the SDK to work with version 2.7 and 3.  You should create an account with  Worldpay Online  so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.    Warning  Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/python27/#get-started", 
            "text": "Download the  repository .  Download the latest version of Apache Thrift (currently 0.10.0).  Extract the repository and change to the  lib/py/  directory.  Run the following command:  sudo python setup.py  install.", 
            "title": "Get started"
        }, 
        {
            "location": "/python27/#run-the-examples", 
            "text": "You can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.   In the first window, run  python runConsumerOWP.py .  In the second window, run  python runProducerOWP.py  OR  python runProducerCallbacksOWP.py .  The two smart devices should communicate with each other and make a payment.", 
            "title": "Run the examples"
        }, 
        {
            "location": "/python27/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.", 
            "title": "See the payments"
        }, 
        {
            "location": "/python27/#if-you-used-your-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .", 
            "title": "If you used your own test API keys"
        }, 
        {
            "location": "/python27/#if-youve-used-worldpays-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  Got to  Settings   API keys  and get your test keys.  Replace the keys in the producer python files.  Re-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "If you've used Worldpay's own test API keys"
        }, 
        {
            "location": "/python27/#debugging", 
            "text": "If you get some odd error messages talking about a rpc-agent:   Try typing the following command:  ps -e | grep rpc  to get the pid(s) of rpc-agents that are running.  Then do  kill  pid , such as  kill 13249234  to kill these processes.  Try re-running the examples.   If you're still having trouble, you can contact us at  . Alternatively, you can  raise an issue in GitHub .", 
            "title": "Debugging"
        }, 
        {
            "location": "/python27/#so-whats-happening", 
            "text": "The Worldpay Within Flows sequence diagram  You can see there are four phases;  Discover ,  Select ,  Pay , and  Release . For more information, see  Worldpay Within .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/python27/#what-iot-devices-can-i-run-this-on", 
            "text": "Note  The devices need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...", 
            "title": "What IoT devices can I run this on?"
        }, 
        {
            "location": "/python27/#want-to-contribute", 
            "text": "If you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the  Internal Structure of Worldpay Within  and  Sample Service Messaging  pages if you want to learn more about how Worldpay Within works.  You can also  raise an issue in GitHub , or contact us directly at  .", 
            "title": "Want to contribute?"
        }, 
        {
            "location": "/java/", 
            "text": "The Java implementation for the Worldpay Within IoT payment SDK. This SDK enables smart devices to discover each other, negotiate a price for services, make a payment (through Worldpay) for services, and then consume services via a \ntrusted trigger\n. For more information, see \nHome\n.\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have the Java SDK installed on your system. And prefereably a Java IDE (Integrated Development Environment) - our dev's love Netbeans, Eclipse and IntelliJ, but it's your choice; we've provided a maven script to build everything. \n\n\nYou should create an account with \nWorldpay Online\n so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.\n\n\n\n\n\n\nWarning\n\n\nMake sure you only use test API keys.\n\n\n\n\nGet started\n\n\n\n\nDownload the \nrepository\n.\n\n\nGet the dependent repos by typing \ngit submodule init\n and then \ngit submodule update --recursive --remote\n\n\n\n\nRun the examples\n\n\nYou can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.\n\n\n\n\nIn the first window, run the consumer JAR\n\n\nIn the second window, run the producer JAR\n\n\nThe two smart devices should communicate with each other and make a payment\n\n\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nYou'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\n\n\nIf you've used Worldpay's own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nGot to \nSettings \n API keys\n and get your test keys.\n\n\nReplace the keys in the producer Java files.\n\n\nRe-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\n\n\nDebugging\n\n\nIf you get some odd error messages talking about a rpc-agent:\n\n\n\n\nTry typing the following command: \nps -e | grep rpc\n to get the pid(s) of rpc-agents that are running.\n\n\nThen do \nkill \npid\n, such as \nkill 13249234\n to kill these processes.\n\n\nTry re-running the examples\n\n\n\n\nIf you're still having trouble, you can contact us at \n. Alternatively, you can \nraise an issue in GitHub\n.\n\n\nSo what's happening?\n\n\n\n\nThe Worldpay Within Flows sequence diagram\n\n\nYou can see there are four phases; \nDiscover\n, \nSelect\n, \nPay\n, and \nRelease\n. For more information, see \nHome\n.\n\n\nWhat IoT devices can I run this on?\n\n\n\n\nNote\n\n\nThe devices need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...\n\n\n\n\nWant to contribute?\n\n\nIf you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the \nInternal Structure of Worldpay Within\n and \nSample Service Messaging\n pages if you want to learn more about how Worldpay Within works.\n\n\nYou can also \nraise an issue in GitHub\n, or contact us directly at \n.", 
            "title": "Java"
        }, 
        {
            "location": "/java/#prerequisites", 
            "text": "Before you get started, you should have the Java SDK installed on your system. And prefereably a Java IDE (Integrated Development Environment) - our dev's love Netbeans, Eclipse and IntelliJ, but it's your choice; we've provided a maven script to build everything.   You should create an account with  Worldpay Online  so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.    Warning  Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/java/#get-started", 
            "text": "Download the  repository .  Get the dependent repos by typing  git submodule init  and then  git submodule update --recursive --remote", 
            "title": "Get started"
        }, 
        {
            "location": "/java/#run-the-examples", 
            "text": "You can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.   In the first window, run the consumer JAR  In the second window, run the producer JAR  The two smart devices should communicate with each other and make a payment", 
            "title": "Run the examples"
        }, 
        {
            "location": "/java/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.", 
            "title": "See the payments"
        }, 
        {
            "location": "/java/#if-you-used-your-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .", 
            "title": "If you used your own test API keys"
        }, 
        {
            "location": "/java/#if-youve-used-worldpays-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  Got to  Settings   API keys  and get your test keys.  Replace the keys in the producer Java files.  Re-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "If you've used Worldpay's own test API keys"
        }, 
        {
            "location": "/java/#debugging", 
            "text": "If you get some odd error messages talking about a rpc-agent:   Try typing the following command:  ps -e | grep rpc  to get the pid(s) of rpc-agents that are running.  Then do  kill  pid , such as  kill 13249234  to kill these processes.  Try re-running the examples   If you're still having trouble, you can contact us at  . Alternatively, you can  raise an issue in GitHub .", 
            "title": "Debugging"
        }, 
        {
            "location": "/java/#so-whats-happening", 
            "text": "The Worldpay Within Flows sequence diagram  You can see there are four phases;  Discover ,  Select ,  Pay , and  Release . For more information, see  Home .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/java/#what-iot-devices-can-i-run-this-on", 
            "text": "Note  The devices need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...", 
            "title": "What IoT devices can I run this on?"
        }, 
        {
            "location": "/java/#want-to-contribute", 
            "text": "If you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the  Internal Structure of Worldpay Within  and  Sample Service Messaging  pages if you want to learn more about how Worldpay Within works.  You can also  raise an issue in GitHub , or contact us directly at  .", 
            "title": "Want to contribute?"
        }, 
        {
            "location": "/dotnet/", 
            "text": "The .NET implementation for the Worldpay Within IoT payment SDK. This SDK, or Software Development Kit, enables smart devices to discover each other, negogiate a price for services, make a payment (through the Worldpay Online Payment gateway) for services, and then consume services via a \ntrusted trigger\n. For more information, see \nHome\n.\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have the .NET 4.5 framework and Visual Studio 2017 (any edition) installed on your system. We've tested this wrapper with Visual 2017 Community Edition.\n\n\nYou should create an account with Worldpay Online so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK. \n\n\n\n\n\n\nWarning\n\n\nMake sure you only use test API keys.\n\n\n\n\nGet Started\n\n\nThe .NET Worldpay Within SDK provides a convenient entry point for application developers who wish to create applications using the Worldpay Within SDK.\n\n\nCurrently, there are no \nNuGet\n published libraries for the SDK. This issue is being tracked in \nIssue #1 on GitHub\n.\n\n\nFor now, you will need to build the project yourself, by following these steps:\n\n\n\n\nClone or download the repository by typing \ngit clone git@github.com:WPTechInnovation/wpw-sdk-dotnet.git\n in a terminal or console. See the \nproject homepage\n on GitHub for more options.\n\n\nOpen up the solution file in Visual Studio 2017 (community edition or better).\n\n\nBuild the solution.  Note that you must be connected to the Internet for NuGet dependencies to be downloaded:\n\n\nApacheThrift 0.10.0\n\n\nCommon.Logging 3.3.1\n\n\nCommon.Logging.Core 3.3.1\n\n\n\n\n\n\nDownload the RPC Agent binary build for your platform. The RPC Agents can be downloaded from \nthe wpw-sdk-iot-core\n project.\n\n\nTo configure the .NET SDK to find the agent, download the agent in to a directory named \nbin\n and set a \nWPW_HOME\n environment variable to point to the directory above it. For example, if \nrpc-agent-windows-386.exe\n is installed in \nC:\\users\\Andy\\wpw\\bin\n, then set \nWPW_HOME\n to \nC:\\users\\Andy\\wpw\n.\n\n\n\n\n\n\n\n\nRun the examples\n\n\nOnce you've loaded the projects in Visual Studio and built the project successfully (please note you can \nreport any problems or errors to us\n on Github), you're good to begin testing.\n\n\nTo run a sample app, run the \nWorldpay.Within.Sample\n project.\n\n\nWe'd recommend using your own test API keys for this. We've left our ones in the code, so that it \"just works\", but you won't be able to see the payments with our keys unless you change them. To do this, open \nSimpleProducer.cs\n and search for \nMerchantServiceKey\n in the \nPSPConfig\n declaration. You can replace the existing \nMerchantServiceKey\n with your own value. \n\n\nThe sample application is a Windows console application. To make a simple payment, do the following:\n\n\n\n\nSelect option 1 \nStart Simple Producer\n. This will start a local RPC Agent and register a separate producer with it. Ths producer has a very simple service declaration.\n\n\nSelect option 3 \nConsume Purchase\n. This will start another RPC Agent and attempt to consume the first product of the first service it finds on the network. (This will most likely be your producer.)\n\n\n\n\nThe sample application produces lots of logging, you can control this by editing the \nApp.config\n file in the root of the sample project directory.\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys:\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nYou'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\n\n\nIf you've used Worldpay's own test API keys:\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nGot to \nSettings \n API keys\n and get your test keys.\n\n\nReplace the keys in \nSimpleProducer.cs\n.\n\n\n\n\nRe-run the sample application and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\nSo what's happening?\n\n\n\n\nThe Worldpay Within Flows sequence diagram\n\n\nYou can see there are four phases; \nDiscover\n, \nSelect\n, \nPay\n, and \nRelease\n. For more information, see \nHome\n.\n\n\nIntroduction to the different .NET projects\n\n\nWorldpay.Within\n\n\nThis is the main .NET wrapper entry point assembly. The public API is contained inside the \nWorldpay.Within\n package.\n\n\nYou can use Sandcastle to build the docs, however they will be published online at some point (see \nIssue 2\n).\n\n\nWorldpay.Within.Rpc\n\n\nThis project contains nothing but the generated RPC wrappers for Thrift; you never edit code in here. This is a separate project because the style and organisation of the code generated by the Thrift compiler is pretty poor; this approach isolates this to a single project.\n\n\nTo rebuild the code, first delete all the existing source files and their directories. This clears out any existing code that may have been moved or removed in a new version. Then run the Thrift compiler:\n\n\nthrift-0.10.0.exe -r -out %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\wrappers\\dotnet\\Worldpay.Within\\Worldpay.Within.Rpc --gen csharp:nullable,union %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\rpc\\wpwithin.thrift\n\n\n\n\nThe \n-r\n is there just for safety, in case subdirectories are used in future for storing dependent Thrift IDL files.\n\n\n\n\nBe aware that the above paths assume that you have downloaded the \nWorldpay Within main SDK project\n in to a regular \"Go\" development struture. However, only the thrift interface files are actually required. You can grab those directly from \nhere\n. There are two files needed: \nwptypes.thrift\n and \nwpwithin.thrift\n, both files must be in the same directory.  They are not included within the .NET repository because they are centrally maintained and used to generate multiple language wrappers.\n\n\nBe sure to refresh the project source tree in Visual Studio to ensure that any newly generated files are included in the project. If you fail to do this, expect compile errors for missing types to be thrown.\n\n\nUsing in your own applications\n\n\nTo use Worldpay Within, add the following DLLs to your project path:\n\n\n\n\nWorldpay.Within.dll\n - this contains the SDK code and public entry points.\n\n\nWorldpay.Within.Rpc.dll\n - the Thrift compiler-generated code to bridge to the core Go SDK.\n\n\nThrift.dll\n - Apache Thrift library. \n\n\nLogging Framework\n - whatever logging framework we're going to use.\n\n\n\n\nTo run a Worldpay Within application, the Thrift RPC code will need to be able to talk to an RPC Agent. The RPC Agent is a standalone application that manages the communication with remote third parties (for example, if you are creating a Consumer then the SDK code communicates with a local RPC Agent using the Thrift protocol, which then talks via HTTP to a remote RPC Agent, which then talks to a local Producer via the Thrift protocol).\n\n\nWant to contribute?\n\n\nIf you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the \nInternal Structure of Worldpay Within\n and \nSample Service Messaging\n pages if you want to learn more about how Worldpay Within works.\n\n\nYou can also \nraise an issue in GitHub\n, or contact us directly at \n.", 
            "title": ".NET"
        }, 
        {
            "location": "/dotnet/#prerequisites", 
            "text": "Before you get started, you should have the .NET 4.5 framework and Visual Studio 2017 (any edition) installed on your system. We've tested this wrapper with Visual 2017 Community Edition.  You should create an account with Worldpay Online so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.     Warning  Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/dotnet/#get-started", 
            "text": "The .NET Worldpay Within SDK provides a convenient entry point for application developers who wish to create applications using the Worldpay Within SDK.  Currently, there are no  NuGet  published libraries for the SDK. This issue is being tracked in  Issue #1 on GitHub .  For now, you will need to build the project yourself, by following these steps:   Clone or download the repository by typing  git clone git@github.com:WPTechInnovation/wpw-sdk-dotnet.git  in a terminal or console. See the  project homepage  on GitHub for more options.  Open up the solution file in Visual Studio 2017 (community edition or better).  Build the solution.  Note that you must be connected to the Internet for NuGet dependencies to be downloaded:  ApacheThrift 0.10.0  Common.Logging 3.3.1  Common.Logging.Core 3.3.1    Download the RPC Agent binary build for your platform. The RPC Agents can be downloaded from  the wpw-sdk-iot-core  project.  To configure the .NET SDK to find the agent, download the agent in to a directory named  bin  and set a  WPW_HOME  environment variable to point to the directory above it. For example, if  rpc-agent-windows-386.exe  is installed in  C:\\users\\Andy\\wpw\\bin , then set  WPW_HOME  to  C:\\users\\Andy\\wpw .", 
            "title": "Get Started"
        }, 
        {
            "location": "/dotnet/#run-the-examples", 
            "text": "Once you've loaded the projects in Visual Studio and built the project successfully (please note you can  report any problems or errors to us  on Github), you're good to begin testing.  To run a sample app, run the  Worldpay.Within.Sample  project.  We'd recommend using your own test API keys for this. We've left our ones in the code, so that it \"just works\", but you won't be able to see the payments with our keys unless you change them. To do this, open  SimpleProducer.cs  and search for  MerchantServiceKey  in the  PSPConfig  declaration. You can replace the existing  MerchantServiceKey  with your own value.   The sample application is a Windows console application. To make a simple payment, do the following:   Select option 1  Start Simple Producer . This will start a local RPC Agent and register a separate producer with it. Ths producer has a very simple service declaration.  Select option 3  Consume Purchase . This will start another RPC Agent and attempt to consume the first product of the first service it finds on the network. (This will most likely be your producer.)   The sample application produces lots of logging, you can control this by editing the  App.config  file in the root of the sample project directory.", 
            "title": "Run the examples"
        }, 
        {
            "location": "/dotnet/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.  If you used your own test API keys:   Login to  Worldpay Online .  You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .   If you've used Worldpay's own test API keys:   Login to  Worldpay Online .  Got to  Settings   API keys  and get your test keys.  Replace the keys in  SimpleProducer.cs .   Re-run the sample application and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "See the payments"
        }, 
        {
            "location": "/dotnet/#so-whats-happening", 
            "text": "The Worldpay Within Flows sequence diagram  You can see there are four phases;  Discover ,  Select ,  Pay , and  Release . For more information, see  Home .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/dotnet/#introduction-to-the-different-net-projects", 
            "text": "", 
            "title": "Introduction to the different .NET projects"
        }, 
        {
            "location": "/dotnet/#worldpaywithin", 
            "text": "This is the main .NET wrapper entry point assembly. The public API is contained inside the  Worldpay.Within  package.  You can use Sandcastle to build the docs, however they will be published online at some point (see  Issue 2 ).", 
            "title": "Worldpay.Within"
        }, 
        {
            "location": "/dotnet/#worldpaywithinrpc", 
            "text": "This project contains nothing but the generated RPC wrappers for Thrift; you never edit code in here. This is a separate project because the style and organisation of the code generated by the Thrift compiler is pretty poor; this approach isolates this to a single project.  To rebuild the code, first delete all the existing source files and their directories. This clears out any existing code that may have been moved or removed in a new version. Then run the Thrift compiler:  thrift-0.10.0.exe -r -out %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\wrappers\\dotnet\\Worldpay.Within\\Worldpay.Within.Rpc --gen csharp:nullable,union %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\rpc\\wpwithin.thrift   The  -r  is there just for safety, in case subdirectories are used in future for storing dependent Thrift IDL files.   Be aware that the above paths assume that you have downloaded the  Worldpay Within main SDK project  in to a regular \"Go\" development struture. However, only the thrift interface files are actually required. You can grab those directly from  here . There are two files needed:  wptypes.thrift  and  wpwithin.thrift , both files must be in the same directory.  They are not included within the .NET repository because they are centrally maintained and used to generate multiple language wrappers.  Be sure to refresh the project source tree in Visual Studio to ensure that any newly generated files are included in the project. If you fail to do this, expect compile errors for missing types to be thrown.", 
            "title": "Worldpay.Within.Rpc"
        }, 
        {
            "location": "/dotnet/#using-in-your-own-applications", 
            "text": "To use Worldpay Within, add the following DLLs to your project path:   Worldpay.Within.dll  - this contains the SDK code and public entry points.  Worldpay.Within.Rpc.dll  - the Thrift compiler-generated code to bridge to the core Go SDK.  Thrift.dll  - Apache Thrift library.   Logging Framework  - whatever logging framework we're going to use.   To run a Worldpay Within application, the Thrift RPC code will need to be able to talk to an RPC Agent. The RPC Agent is a standalone application that manages the communication with remote third parties (for example, if you are creating a Consumer then the SDK code communicates with a local RPC Agent using the Thrift protocol, which then talks via HTTP to a remote RPC Agent, which then talks to a local Producer via the Thrift protocol).", 
            "title": "Using in your own applications"
        }, 
        {
            "location": "/dotnet/#want-to-contribute", 
            "text": "If you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checking out the  Internal Structure of Worldpay Within  and  Sample Service Messaging  pages if you want to learn more about how Worldpay Within works.  You can also  raise an issue in GitHub , or contact us directly at  .", 
            "title": "Want to contribute?"
        }, 
        {
            "location": "/getting-started-with-go/", 
            "text": "Getting started with Go\n\n\nTo code against the raw Go SDK, you will need to install Go and the Golang SDK. Alternatively, you can code against one of the multiple language wrappers, which give access to the SDK. \n\n\nThe Golang SDK communicates with these other languages using RPC calls (in both directions), and the wrappers in the background interface using Thrift. This is not exposed to you as a developer; you work with the Interface layer in your language of choice. We've got SDKs in the following languages:\n\n\n  \nNode.js\n\n  \nPython\n\n  \nJava\n\n  \n.NET\n\n\n\n\nThe binaries (if you don't want to build from source)\n\n\nPlease see the \nReleases\n section of GitHub for access to pre-built binaries of the RPC Agent and Dev Client apps. Both of the apps have been built for 32bit and 64bit architectures on Windows, MacOS, Linux and Linux (ARM).\n\n\nWhile the RPC Agent can be run from anywhere, it makes sense to add it to the directory of the application which will call it. The reason for this is that each application needs it own running instance of the RPC Agent and it can easily get confusing when there are multiple applications and agents deployed.\n\n\nPlease see the examples in both the \nJava\n and \nNode.JS\n wrappers. These examples currently hold binaries for MacOS x64. We suggest replacing that binary with an alternate build, if required.\n\n\nThe dev client can be run from anywhere as it is not coupled with anything else.\n\n\nUsage\n\n\n\n\nRPC Agent \n./rpc-agent -configfile \nfilename\n/filename\n. Please see explanation of rpc-agent config file for further info.\n\n\nDev Client \n./dev-client\n\n\n\n\nInstall - if you want to go from the Go source files\n\n\n\n\nInstall the Go command line\n\n\nSet up the environmental variables correctly; you only need to set \n$GOPATH\n, and that should be set as \n//\n where you want the code, for example: \n/src/innovation.worldpay.com\n\n\nClone the repo to \n$GOPATH/src/innovation.worldpay.com\n\n\nGet the dependencies: \ngo get github.com/Sirupsen/logrus\n\n\nGet the dependencies: \ngo get github.com/gorilla/mux\n\n\nGet the dependencies: \ngo get github.com/nu7hatch/gouuid\n\n\nGet the dependencies: \ngo get git.apache.org/thrift.git/lib/go/thrift\n\n\n\n\nConfiguration file versus command line flags\n\n\nThe RPC client takes command line flags, for example \n-port 9091\n. It can also take the flag \n-configfile 'conf.json'\n, so you can specify the configuration in a config file. For example:\n\n\n{\n\n    \nWorldpayWithinConfig\n:\n \n{\n\n        \nBufferSize\n \n:\n \n100\n,\n\n        \nBuffered\n:\n \nfalse\n,\n\n        \nFramed\n:\n \nfalse\n,\n\n        \nHost\n:\n \n127.0.0.1\n,\n\n        \nLogfile\n:\n \nworldpayWithin.log\n,\n\n        \nLoglevel\n:\n \nwarn\n,\n\n        \nPort\n:\n \n9081\n,\n\n        \nProtocol\n:\n \nbinary\n,\n\n        \nSecure\n:\n \nfalse\n\n    \n}\n\n\n}\n\n\n\n\n\nHow to run two example apps on one machine\n\n\n\n\nThe output of the log files for the orchestration of the flow.\n\n\n\n\nShowing the payment in online.worldpay.com.\n\n\nIn the example, we're using two different ports:\n\n\n\n\nJava - 9090 - Producer\n\n\nNode.js - 9091 - Consumer\n\n\n\n\nFollow these steps to run two apps on one machine:\n\n\n\n\nOpen two terminal windows.\n\n\nConfigure the rpc agent in each terminal window to run on each of the ports. \n\n\nIn the producer window, run the RPC on port \n9090\n.\n\n\nIn the consumer window, run the RPC on port \n9091\n.\n\n\nConfigure the Java app to run as the producer on \n9090\n.\n\n\nConfigure the Node.js app to run as the consumer on \n9091\n, by changing the \ncreateClient\n in the example code.\n\n\nRun the Java producer app so we're broadcasting. The RPC agent broadcasting will continue to run in the background while the Java program has exited.\n\n\nRun the Node.js consumer app immediately.\n\n\nThe \nDiscover\n, \nSelect\n, \nPay\n and \nRelease\n flows will all be triggered, as you can see above.", 
            "title": "Go"
        }, 
        {
            "location": "/getting-started-with-go/#getting-started-with-go", 
            "text": "To code against the raw Go SDK, you will need to install Go and the Golang SDK. Alternatively, you can code against one of the multiple language wrappers, which give access to the SDK.   The Golang SDK communicates with these other languages using RPC calls (in both directions), and the wrappers in the background interface using Thrift. This is not exposed to you as a developer; you work with the Interface layer in your language of choice. We've got SDKs in the following languages: \n   Node.js \n   Python \n   Java \n   .NET", 
            "title": "Getting started with Go"
        }, 
        {
            "location": "/getting-started-with-go/#the-binaries-if-you-dont-want-to-build-from-source", 
            "text": "Please see the  Releases  section of GitHub for access to pre-built binaries of the RPC Agent and Dev Client apps. Both of the apps have been built for 32bit and 64bit architectures on Windows, MacOS, Linux and Linux (ARM).  While the RPC Agent can be run from anywhere, it makes sense to add it to the directory of the application which will call it. The reason for this is that each application needs it own running instance of the RPC Agent and it can easily get confusing when there are multiple applications and agents deployed.  Please see the examples in both the  Java  and  Node.JS  wrappers. These examples currently hold binaries for MacOS x64. We suggest replacing that binary with an alternate build, if required.  The dev client can be run from anywhere as it is not coupled with anything else.", 
            "title": "The binaries (if you don't want to build from source)"
        }, 
        {
            "location": "/getting-started-with-go/#usage", 
            "text": "RPC Agent  ./rpc-agent -configfile  filename /filename . Please see explanation of rpc-agent config file for further info.  Dev Client  ./dev-client", 
            "title": "Usage"
        }, 
        {
            "location": "/getting-started-with-go/#install-if-you-want-to-go-from-the-go-source-files", 
            "text": "Install the Go command line  Set up the environmental variables correctly; you only need to set  $GOPATH , and that should be set as  //  where you want the code, for example:  /src/innovation.worldpay.com  Clone the repo to  $GOPATH/src/innovation.worldpay.com  Get the dependencies:  go get github.com/Sirupsen/logrus  Get the dependencies:  go get github.com/gorilla/mux  Get the dependencies:  go get github.com/nu7hatch/gouuid  Get the dependencies:  go get git.apache.org/thrift.git/lib/go/thrift", 
            "title": "Install - if you want to go from the Go source files"
        }, 
        {
            "location": "/getting-started-with-go/#configuration-file-versus-command-line-flags", 
            "text": "The RPC client takes command line flags, for example  -port 9091 . It can also take the flag  -configfile 'conf.json' , so you can specify the configuration in a config file. For example:  { \n     WorldpayWithinConfig :   { \n         BufferSize   :   100 , \n         Buffered :   false , \n         Framed :   false , \n         Host :   127.0.0.1 , \n         Logfile :   worldpayWithin.log , \n         Loglevel :   warn , \n         Port :   9081 , \n         Protocol :   binary , \n         Secure :   false \n     }  }", 
            "title": "Configuration file versus command line flags"
        }, 
        {
            "location": "/getting-started-with-go/#how-to-run-two-example-apps-on-one-machine", 
            "text": "The output of the log files for the orchestration of the flow.   Showing the payment in online.worldpay.com.  In the example, we're using two different ports:   Java - 9090 - Producer  Node.js - 9091 - Consumer   Follow these steps to run two apps on one machine:   Open two terminal windows.  Configure the rpc agent in each terminal window to run on each of the ports.   In the producer window, run the RPC on port  9090 .  In the consumer window, run the RPC on port  9091 .  Configure the Java app to run as the producer on  9090 .  Configure the Node.js app to run as the consumer on  9091 , by changing the  createClient  in the example code.  Run the Java producer app so we're broadcasting. The RPC agent broadcasting will continue to run in the background while the Java program has exited.  Run the Node.js consumer app immediately.  The  Discover ,  Select ,  Pay  and  Release  flows will all be triggered, as you can see above.", 
            "title": "How to run two example apps on one machine"
        }, 
        {
            "location": "/how-it-works/", 
            "text": "1. Understand the flows\n\n\nBefore you start it's worth familiarising yourself with how Worldpay Within works. We recommend following the pre-established flows in the order they are presented for each Thing (Machine A and Machine B). If you stray from the flows, we cannot guarantee that the SDKs will work.\n\n\nThe devices are not synchronised by the SDK, so you'll need to ensure that the SDKs call the Worldpay Within API in the correct order. If you follow the steps below, then the outcome should be as expected.\n\n\nWorldpay Within flow\n\n\nThe Consumer (Shopper) flow\n\n\nThe consumer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.\n\n\n\n\nThe consumer flow.\n\n\nThe Producer (Merchant) flow\n\n\nThe producer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.\n\n\n\n\nThe producer flow.\n\n\n2. Choose your SDK\n\n\nFor the alpha release, we ecided to go with five languages. The documentation and API specification can be found here:\n\n\n  \nNode.js\n\n  \nPython\n\n  \nJava\n\n  \n.NET\n\n  \nGo", 
            "title": "How it works"
        }, 
        {
            "location": "/how-it-works/#146-understand-the-flows", 
            "text": "Before you start it's worth familiarising yourself with how Worldpay Within works. We recommend following the pre-established flows in the order they are presented for each Thing (Machine A and Machine B). If you stray from the flows, we cannot guarantee that the SDKs will work.  The devices are not synchronised by the SDK, so you'll need to ensure that the SDKs call the Worldpay Within API in the correct order. If you follow the steps below, then the outcome should be as expected.", 
            "title": "1. Understand the flows"
        }, 
        {
            "location": "/how-it-works/#worldpay-within-flow", 
            "text": "", 
            "title": "Worldpay Within flow"
        }, 
        {
            "location": "/how-it-works/#the-consumer-shopper-flow", 
            "text": "The consumer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.   The consumer flow.", 
            "title": "The Consumer (Shopper) flow"
        }, 
        {
            "location": "/how-it-works/#the-producer-merchant-flow", 
            "text": "The producer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.   The producer flow.", 
            "title": "The Producer (Merchant) flow"
        }, 
        {
            "location": "/how-it-works/#246-choose-your-sdk", 
            "text": "For the alpha release, we ecided to go with five languages. The documentation and API specification can be found here: \n   Node.js \n   Python \n   Java \n   .NET \n   Go", 
            "title": "2. Choose your SDK"
        }, 
        {
            "location": "/architecture/", 
            "text": "To complement the architecture, we have released the Worldpay Within SDK. The intention for the SDK is to encapsulate implementation and help third party vendors and developers integration into their Internet of Things (IoT) solutions.\n\n\nThe core of the SDK is developed in the Go programming language with wrappers created for Java, Node.js, Python and .NET. Service delivery and broadcast have been implemented using TCP/IP networking.\n\n\nFor more information about the low level service messaging, click \nhere\n.\n\n\nArchitecture Overview\n\n\nIn the IoT, each Thing will perform the function it is designed for, be it acting as a sensor, a controller or both. In order for the Thing to be able to make and receive payments for services they can provide to other Things, they need to add the payments functionality contained in Worldpay Within.\n\n\n\n\nFigure 1. Worldpay Within Pluggable agent.\n\n\nThings in the IoT will be implemented on dedicated low cost processor systems. The Thing and Worldpay Within must co-exist and operate on the resources provided by these devices, as demonstrated in Figure 2.\n\n\n\n\nFigure 2. Worldpay Within Logical Overview.\n\n\nIn order to make and receive payments in the IoT, a Thing must be able to perform the roles of consumer (shopper), to make a payment for services, and the producer (merchant) to receive a payment for provision of services. In the Worldpay Within IoT architecture, the \u201cconsumer\u201d pays for services by supporting Host Card Emulation (HCE). The \u201cmerchant\u201d or \"producer\" receives payments for services by supporting Host Terminal Emulation (HTE). Worldpay Within contains both an HCE Brain and HTE Brain functionalities, ensuring a Thing can both consume and supply services. These services are provided through a series of public APIs, described within this document.\n\n\nHCE and HTE require the secure storage and use of the credentials during the payments process. This requires the use of secure processing within the Thing in a \u201cSecure Execution Environment\u201d.\n\n\nFor HCE Things, these credentials include the details of the \u201ccard\u201d which the payment will be made from. For HTE Things, these credentials include the details the Merchant requires to perform transactions with Worldpay.\n\n\nAs well as the provision of the payment for the services, Worldpay Within provides for the generation and validation of secure service tokens, which allow for services to be consumed in part or together, but separately from the payments functionality.\n\n\nWorldpay Within IoT Service Architecture\n\n\nThe provision of a service within the Worldpay IoT system is performed in 4 phases, as shown in Figure 3, these being:  \nDiscover\n, \nSelect\n, \nPay\n, and \nRelease\n. Each of these phases are described in the following sections.\n\n\n\n\nFigure 3. The 4 phases of Worldpay Within.\n\n\nDiscover\n\n\nEach Thing that offers services, the service \u2018supplier\u2019 shall broadcast it\u2019s list of available services, as shown in Figure 4 below. When a potential \u2018consumer\u2019 of the service connects with \u2018supplier\u2019 it can request details of the services offered.\n\n\nProviding a suitable service is discovered, the consumer then requests the service from the supplier, and price negotiations can begin.\n\n\n\n\nFigure 4. IoT Service discovery.\n\n\nService Discovery APIs\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nbroadcast\n\n\nserver_UUID\n\n\nAdvertising services and identifying the sender\n\n\n\n\n\n\nrequest services\n\n\nnone\n\n\nRequest a list of all services\n\n\n\n\n\n\nservices_response\n\n\nlist of services\n, \nserver_UUID\n\n\nProvide client with a list of possible services that the sender can provide\n\n\n\n\n\n\n\n\nService discovery messages\n\n\nA broadcast message that includes Thing B\u2019s UUID is sent.\n\n\nUpon receiving the message Thing A connects to Thing B and requests the list of available services.\n\n\nThing B responds with a list identifying the services available.\n\n\nSelect\n\n\nOnce a suitable service has been discovered, the shopper will select the choice. The provider may offer the same service at different rates depending on the number of units of service to be purchased. The process is outlined in Figure 5. The outcome of the process is an agreement to purchase an amount of service and a total price for the service to be provided. The service provider can then request payment for the agreed service and price.\n\n\n\n\nFigure 5. IoT Service Negotiation.\n\n\nService selection APIs\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nprice_request\n\n\nservice_id\n\n\nRequest a list of all prices for a given service.\n\n\n\n\n\n\nprice_response\n\n\nserver_UUID\n, list of prices, (\nservice_id\n, \nprice_id\n, \nprice_per_unit\n, \nunit_ID\n, \nunit_description\n, \nprice_description\n)\n\n\nProvide the client with a list of prices for a given service. A price object contains the per unit price.\n\n\n\n\n\n\nprice_select\n\n\nservice_id\n, \nprice_id\n, \nnumber_of_units\n, \nclient_UUID\n\n\nSelect a price with \nprice_id\n, for \nservice_id\n for a number of units.\n\n\n\n\n\n\nprice_select_response\n\n\nprice_id\n, \nnumber_of_units\n, \ntotal_price\n, \nserver_UUID\n, \nclient_UUID\n, \npayment_ref_ID\n, \nMerchant_Client_key\n\n\nCommunicate the expected total price to the client.\n\n\n\n\n\n\n\n\nService selection messages\n\n\nA price request is sent containing the selected \nservice_id\n.\n\n\nThe response from Thing B contains a list of price items; each item should contain a \nprice_id\n, per unit price, \nunit_ID\n and description fields of both the unit and the price.\n\n\nThing A then selects an appropriate \nprice_id\n by sending a request with its \nclient_UUID\n, the selected \nservice_id\n, the \nprice_id\n, and the number of items required.\n\n\nIf the number of items falls within the correct number of items for the price selected, then Thing B responds with a price select response containing the \nservice_id\n, \nprice_id\n, the total price, the \nservice_UUID\n and a reference for the payment and its Merchant Client key. Otherwise Thing B shall return the number of units it can supply along with the correct price, and additional details required to initiate the payment.\n\n\nPay\n\n\nThe payment process with Worldpay is a two stage process, split between the consumer and merchant Things involved in the transaction, these stages are:\n\n\n\n\n\n\nClient Token Request, and\n\n\n\n\n\n\nPayment Authorisation Request. (Also known as Order Request)\n\n\n\n\n\n\nDuring the first stage, the consumer sends Worldpay their payment credentials and the merchants Client Key. We return a Client Token, which the consumer passes to the Merchant. This allows the merchant to perform the payment authorisation request with Worldpay by providing the Client Token and transaction details.\n\n\nThis payment process ensures that the consumer does not pass their payment credentials to the merchant, only to Worldpay.\n\n\nClient token request\n\n\nThe first step in the payment process is when Thing A receives the \nMerchant_Client_Key\n from Thing B. Thing B passes their public Client Key to Thing A as part of the \nprice_select_response\n during the Service Negotiation phase. Upon receiving the Client Key from Thing B, Thing A connects with Worldpay to request the client token from us. This request includes Thing A\u2019s payment credentials: Card PAN, expiry, and the \nclient_key\n of Thing B. Worldpay will respond with a message that includes a \nclient_token\n. This is shown in Figure 6.\n\n\n\n\nFigure 6. IoT Payment process - client token request.\n\n\nClient token request APIs\n\n\nThing A to Worldpay client token request\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nclient_token_request\n\n\nPayment_method\n, \nreusable_flag\n, \nMerchant_client_key\n, \nPayment_method\n (\nname\n, \nPAN\n, \nexpiryMonth\n, \nexpiryYear\n, \ntype\n)\n\n\nRequest a client token from Worldpay, whilst providing us with the payment credentials.\n\n\n\n\n\n\nclient_token_response\n\n\nclient_token\n, \nreusable_flag\n, \npayment_method_response\n (\ntype\n, \nname\n, \nexpiryMonth\n, \nexpiryYear\n, \ncard_type\n, \ncard_scheme\\_type\n, \ncard_scheme_name\n, \nmasked_card_number\n, \ncard_product_type_description_non_contactless\n, \ncard_product_type_description_contactless\n, \ncard_issuer\n, \ncountry_code\n, \ncard_class\n, \npre-paid\n)\n\n\nResponse from Worldpay containing the client_token.\n\n\n\n\n\n\nPayment_request\n\n\nclient_token\n, \nclient_UUID\n, \npayment_ref_ID\n\n\nThe \nclient_token\n is passed to Thing B to allow the 2\nnd\n part of the transaction process to take place.\n\n\n\n\n\n\n\n\nThing A will connect to Worldpay using Transport Layer Security (TLS). It will then request a \nclient_token\n by securely (see 2.2.1) sending a JSON message containing the \npaymentMethod\n, its payment credentials (PAN, expiry) to us, along with the \nclient_key\n from Thing B. In addition a flag indicating if the client details can be used in future is sent, for IoT this should always be set \u2018reusable\u2019:\u2019false\u2019 in order to force generation of a new client token for each transaction.\n\n\nA successful response will be an HTTP \nPOST\n response containing fields: \nclient_token\n, \nreusable_flag\n and the \npayment_method_response\n. Once received, the \nclient_token\n shall be passed to Thing B.\n\n\nA sample request is shown in Appendix B: Sample Service Messaging.\n\n\nSee \nAPI keys\n for documentation for \nclient_token_request\n and \nclient_token_repsonse\n APIs data descriptions.\n\n\nPayment authorisation request\n\n\nThing B will process the order and request the payment from Worldpay providing its service key, \nclient_token\n, transaction currency and payment amount. This is transmitted to Worldpay over TLS. After successful processing the payment, Worldpay will provide a payment response. Thing B shall then generate a service token, which Thing A may use in future to obtain the services that the payment has been made for. This is shown in Figure 7.\n\n\n\n\nFigure 7. Payment Authorisation Request.\n\n\nPayment authorisation request APIs\n\n\nThing B to Worldpay payment authorisation request\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\norder_request\n\n\nclient_service_key\n, \nclient_token\n, \ncurrency_code\n, \namount\n, \norder_description\n, \ncustomer_order_code\n\n\nRequest payment from Worldpay.\n\n\n\n\n\n\norder_response\n\n\norder_code\n, \nclient_token\n, \norder_description\n, \namount\n, \ncurrency_code\n, \npayment_status\n, \ncustomer_order_code\n, \nenvironment\n, \nrisk_score\n, \npayment_response\n (\ntype\n, \nname\n, \nexpiryMonth\n, \nexpiryYear\n, \ncard_type\n, \ncard_scheme_type\n, \ncard_scheme_name\n, \nmasked_card_number\n, \ncard_product_type_description_non_contactless\n, \ncard_product_type_description_contactless\n, \ncard_issuer\n, \ncountry_code\n, \ncard_class\n, \npre-paid\n)\n\n\nPayment response indicating a successful transaction on the Worldpay platform.\n\n\n\n\n\n\n\n\nThing B will assemble a message to be posted to Worldpay that contains the client token, Service key, the amount, currency and transaction description. We will then perform an authorisation using the payment credentials identified by the \nclient_token\n. A successful authorisation will result in a \npayment_status\n of SUCCESS being returned to Thing B.\n\n\nThing B to Thing A service token\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\npayment_request_response\n\n\nservice_delivery_token\n, \nserver_UUID\n, \nclient_UUID\n, \ntotal_paid\n\n\nservice_delivery_token\n is passed to ThingB.\n\n\n\n\n\n\n\n\nThing B shall then generate a cryptographically secure \nservice_delivery_token\n, which can be used by Thing A to request provision of services from Thing B.\n\n\nDelivery\n\n\nOnce the payment has been made, Thing B shall return to broadcasting its available services. Thing A will now be able to consume the service from Thing B by providing the \nservice_delivery_token\n. The service delivery may be in a single step, or over time. An overview of service delivery is shown in Figure 8.\n\n\n\n\nFigure 8. Service delivery.\n\n\nOnce in possession of a service_token, Thing A may then request the service be provided. The service could be consumed in one session, or in several sessions over time, depending on the nature of the service and number of units purchased. Thing A may repeatedly send service delivery requests until Thing B indicates that the service has been delivered.\n\n\nService Delivery APIs\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\npayment_request_response\n\n\nservice_delivery_token\n, \nserver_UUID\n, \nclient_UUID\n, \ntotal_paid\n\n\nservice_delivery_token\n is passed to ThingB.\n\n\n\n\n\n\nbroadcast\n\n\nserver_UUID\n\n\nAdvertising services and identifying the sender.\n\n\n\n\n\n\ndelivery_begin_request\n\n\nservice_delivery_token\n, \nclient_UUID\n, \nnumber_of_units_to_supply\n\n\nRequest the service item, with the \nservice_delivery_token\n providing right to receive the service, and amount of service to be supplied.\n\n\n\n\n\n\ndelivery_begin_response\n\n\nserver_UUID\n, \nservice_delivery_token\n, \nclient_UUID\n, \nnumber_of_units_to_be_supplied\n\n\nResponse for the service delivery. Confirmation of number of service units to be supplied (Allowing for less units than requested).\n\n\n\n\n\n\ndelivery_end\n\n\nclient_UUID\n, \nnumber_of_units_received\n\n\nConfirmation of service received.\n\n\n\n\n\n\ndelivery_end_response\n\n\nserver_UUID\n, \nservice_delivery_token\n, \nclient_UUID\n, \nnumber_of_units_just_supplied\n, \nnumber_of_units_remaining\n\n\nService end indicating outstanding service credits and token for subsequent delivery.\n\n\n\n\n\n\n\n\nThing A sends a message with the \nservice_delivery_token\n to Thing B, along with the amount of service it wishes to consume. The response shall confirm the amount of service units that Thing B can supply to Thing A at that time. Once the service has been delivered, Thing A shall confirm the amount of service units it has received, with Thing B responding, stating the number of units still remaining to Thing A, if any.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture-overview", 
            "text": "In the IoT, each Thing will perform the function it is designed for, be it acting as a sensor, a controller or both. In order for the Thing to be able to make and receive payments for services they can provide to other Things, they need to add the payments functionality contained in Worldpay Within.   Figure 1. Worldpay Within Pluggable agent.  Things in the IoT will be implemented on dedicated low cost processor systems. The Thing and Worldpay Within must co-exist and operate on the resources provided by these devices, as demonstrated in Figure 2.   Figure 2. Worldpay Within Logical Overview.  In order to make and receive payments in the IoT, a Thing must be able to perform the roles of consumer (shopper), to make a payment for services, and the producer (merchant) to receive a payment for provision of services. In the Worldpay Within IoT architecture, the \u201cconsumer\u201d pays for services by supporting Host Card Emulation (HCE). The \u201cmerchant\u201d or \"producer\" receives payments for services by supporting Host Terminal Emulation (HTE). Worldpay Within contains both an HCE Brain and HTE Brain functionalities, ensuring a Thing can both consume and supply services. These services are provided through a series of public APIs, described within this document.  HCE and HTE require the secure storage and use of the credentials during the payments process. This requires the use of secure processing within the Thing in a \u201cSecure Execution Environment\u201d.  For HCE Things, these credentials include the details of the \u201ccard\u201d which the payment will be made from. For HTE Things, these credentials include the details the Merchant requires to perform transactions with Worldpay.  As well as the provision of the payment for the services, Worldpay Within provides for the generation and validation of secure service tokens, which allow for services to be consumed in part or together, but separately from the payments functionality.", 
            "title": "Architecture Overview"
        }, 
        {
            "location": "/architecture/#worldpay-within-iot-service-architecture", 
            "text": "The provision of a service within the Worldpay IoT system is performed in 4 phases, as shown in Figure 3, these being:   Discover ,  Select ,  Pay , and  Release . Each of these phases are described in the following sections.   Figure 3. The 4 phases of Worldpay Within.", 
            "title": "Worldpay Within IoT Service Architecture"
        }, 
        {
            "location": "/architecture/#discover", 
            "text": "Each Thing that offers services, the service \u2018supplier\u2019 shall broadcast it\u2019s list of available services, as shown in Figure 4 below. When a potential \u2018consumer\u2019 of the service connects with \u2018supplier\u2019 it can request details of the services offered.  Providing a suitable service is discovered, the consumer then requests the service from the supplier, and price negotiations can begin.   Figure 4. IoT Service discovery.", 
            "title": "Discover"
        }, 
        {
            "location": "/architecture/#service-discovery-apis", 
            "text": "Key  Parameters  Purpose      broadcast  server_UUID  Advertising services and identifying the sender    request services  none  Request a list of all services    services_response  list of services ,  server_UUID  Provide client with a list of possible services that the sender can provide", 
            "title": "Service Discovery APIs"
        }, 
        {
            "location": "/architecture/#service-discovery-messages", 
            "text": "A broadcast message that includes Thing B\u2019s UUID is sent.  Upon receiving the message Thing A connects to Thing B and requests the list of available services.  Thing B responds with a list identifying the services available.", 
            "title": "Service discovery messages"
        }, 
        {
            "location": "/architecture/#select", 
            "text": "Once a suitable service has been discovered, the shopper will select the choice. The provider may offer the same service at different rates depending on the number of units of service to be purchased. The process is outlined in Figure 5. The outcome of the process is an agreement to purchase an amount of service and a total price for the service to be provided. The service provider can then request payment for the agreed service and price.   Figure 5. IoT Service Negotiation.", 
            "title": "Select"
        }, 
        {
            "location": "/architecture/#service-selection-apis", 
            "text": "Key  Parameters  Purpose      price_request  service_id  Request a list of all prices for a given service.    price_response  server_UUID , list of prices, ( service_id ,  price_id ,  price_per_unit ,  unit_ID ,  unit_description ,  price_description )  Provide the client with a list of prices for a given service. A price object contains the per unit price.    price_select  service_id ,  price_id ,  number_of_units ,  client_UUID  Select a price with  price_id , for  service_id  for a number of units.    price_select_response  price_id ,  number_of_units ,  total_price ,  server_UUID ,  client_UUID ,  payment_ref_ID ,  Merchant_Client_key  Communicate the expected total price to the client.", 
            "title": "Service selection APIs"
        }, 
        {
            "location": "/architecture/#service-selection-messages", 
            "text": "A price request is sent containing the selected  service_id .  The response from Thing B contains a list of price items; each item should contain a  price_id , per unit price,  unit_ID  and description fields of both the unit and the price.  Thing A then selects an appropriate  price_id  by sending a request with its  client_UUID , the selected  service_id , the  price_id , and the number of items required.  If the number of items falls within the correct number of items for the price selected, then Thing B responds with a price select response containing the  service_id ,  price_id , the total price, the  service_UUID  and a reference for the payment and its Merchant Client key. Otherwise Thing B shall return the number of units it can supply along with the correct price, and additional details required to initiate the payment.", 
            "title": "Service selection messages"
        }, 
        {
            "location": "/architecture/#pay", 
            "text": "The payment process with Worldpay is a two stage process, split between the consumer and merchant Things involved in the transaction, these stages are:    Client Token Request, and    Payment Authorisation Request. (Also known as Order Request)    During the first stage, the consumer sends Worldpay their payment credentials and the merchants Client Key. We return a Client Token, which the consumer passes to the Merchant. This allows the merchant to perform the payment authorisation request with Worldpay by providing the Client Token and transaction details.  This payment process ensures that the consumer does not pass their payment credentials to the merchant, only to Worldpay.", 
            "title": "Pay"
        }, 
        {
            "location": "/architecture/#client-token-request", 
            "text": "The first step in the payment process is when Thing A receives the  Merchant_Client_Key  from Thing B. Thing B passes their public Client Key to Thing A as part of the  price_select_response  during the Service Negotiation phase. Upon receiving the Client Key from Thing B, Thing A connects with Worldpay to request the client token from us. This request includes Thing A\u2019s payment credentials: Card PAN, expiry, and the  client_key  of Thing B. Worldpay will respond with a message that includes a  client_token . This is shown in Figure 6.   Figure 6. IoT Payment process - client token request.", 
            "title": "Client token request"
        }, 
        {
            "location": "/architecture/#client-token-request-apis", 
            "text": "", 
            "title": "Client token request APIs"
        }, 
        {
            "location": "/architecture/#thing-a-to-worldpay-client-token-request", 
            "text": "Key  Parameters  Purpose      client_token_request  Payment_method ,  reusable_flag ,  Merchant_client_key ,  Payment_method  ( name ,  PAN ,  expiryMonth ,  expiryYear ,  type )  Request a client token from Worldpay, whilst providing us with the payment credentials.    client_token_response  client_token ,  reusable_flag ,  payment_method_response  ( type ,  name ,  expiryMonth ,  expiryYear ,  card_type ,  card_scheme\\_type ,  card_scheme_name ,  masked_card_number ,  card_product_type_description_non_contactless ,  card_product_type_description_contactless ,  card_issuer ,  country_code ,  card_class ,  pre-paid )  Response from Worldpay containing the client_token.    Payment_request  client_token ,  client_UUID ,  payment_ref_ID  The  client_token  is passed to Thing B to allow the 2 nd  part of the transaction process to take place.     Thing A will connect to Worldpay using Transport Layer Security (TLS). It will then request a  client_token  by securely (see 2.2.1) sending a JSON message containing the  paymentMethod , its payment credentials (PAN, expiry) to us, along with the  client_key  from Thing B. In addition a flag indicating if the client details can be used in future is sent, for IoT this should always be set \u2018reusable\u2019:\u2019false\u2019 in order to force generation of a new client token for each transaction.  A successful response will be an HTTP  POST  response containing fields:  client_token ,  reusable_flag  and the  payment_method_response . Once received, the  client_token  shall be passed to Thing B.  A sample request is shown in Appendix B: Sample Service Messaging.  See  API keys  for documentation for  client_token_request  and  client_token_repsonse  APIs data descriptions.", 
            "title": "Thing A to Worldpay client token request"
        }, 
        {
            "location": "/architecture/#payment-authorisation-request", 
            "text": "Thing B will process the order and request the payment from Worldpay providing its service key,  client_token , transaction currency and payment amount. This is transmitted to Worldpay over TLS. After successful processing the payment, Worldpay will provide a payment response. Thing B shall then generate a service token, which Thing A may use in future to obtain the services that the payment has been made for. This is shown in Figure 7.   Figure 7. Payment Authorisation Request.", 
            "title": "Payment authorisation request"
        }, 
        {
            "location": "/architecture/#payment-authorisation-request-apis", 
            "text": "", 
            "title": "Payment authorisation request APIs"
        }, 
        {
            "location": "/architecture/#thing-b-to-worldpay-payment-authorisation-request", 
            "text": "Key  Parameters  Purpose      order_request  client_service_key ,  client_token ,  currency_code ,  amount ,  order_description ,  customer_order_code  Request payment from Worldpay.    order_response  order_code ,  client_token ,  order_description ,  amount ,  currency_code ,  payment_status ,  customer_order_code ,  environment ,  risk_score ,  payment_response  ( type ,  name ,  expiryMonth ,  expiryYear ,  card_type ,  card_scheme_type ,  card_scheme_name ,  masked_card_number ,  card_product_type_description_non_contactless ,  card_product_type_description_contactless ,  card_issuer ,  country_code ,  card_class ,  pre-paid )  Payment response indicating a successful transaction on the Worldpay platform.     Thing B will assemble a message to be posted to Worldpay that contains the client token, Service key, the amount, currency and transaction description. We will then perform an authorisation using the payment credentials identified by the  client_token . A successful authorisation will result in a  payment_status  of SUCCESS being returned to Thing B.", 
            "title": "Thing B to Worldpay payment authorisation request"
        }, 
        {
            "location": "/architecture/#thing-b-to-thing-a-service-token", 
            "text": "Key  Parameters  Purpose      payment_request_response  service_delivery_token ,  server_UUID ,  client_UUID ,  total_paid  service_delivery_token  is passed to ThingB.     Thing B shall then generate a cryptographically secure  service_delivery_token , which can be used by Thing A to request provision of services from Thing B.", 
            "title": "Thing B to Thing A service token"
        }, 
        {
            "location": "/architecture/#delivery", 
            "text": "Once the payment has been made, Thing B shall return to broadcasting its available services. Thing A will now be able to consume the service from Thing B by providing the  service_delivery_token . The service delivery may be in a single step, or over time. An overview of service delivery is shown in Figure 8.   Figure 8. Service delivery.  Once in possession of a service_token, Thing A may then request the service be provided. The service could be consumed in one session, or in several sessions over time, depending on the nature of the service and number of units purchased. Thing A may repeatedly send service delivery requests until Thing B indicates that the service has been delivered.", 
            "title": "Delivery"
        }, 
        {
            "location": "/architecture/#service-delivery-apis", 
            "text": "Key  Parameters  Purpose      payment_request_response  service_delivery_token ,  server_UUID ,  client_UUID ,  total_paid  service_delivery_token  is passed to ThingB.    broadcast  server_UUID  Advertising services and identifying the sender.    delivery_begin_request  service_delivery_token ,  client_UUID ,  number_of_units_to_supply  Request the service item, with the  service_delivery_token  providing right to receive the service, and amount of service to be supplied.    delivery_begin_response  server_UUID ,  service_delivery_token ,  client_UUID ,  number_of_units_to_be_supplied  Response for the service delivery. Confirmation of number of service units to be supplied (Allowing for less units than requested).    delivery_end  client_UUID ,  number_of_units_received  Confirmation of service received.    delivery_end_response  server_UUID ,  service_delivery_token ,  client_UUID ,  number_of_units_just_supplied ,  number_of_units_remaining  Service end indicating outstanding service credits and token for subsequent delivery.     Thing A sends a message with the  service_delivery_token  to Thing B, along with the amount of service it wishes to consume. The response shall confirm the amount of service units that Thing B can supply to Thing A at that time. Once the service has been delivered, Thing A shall confirm the amount of service units it has received, with Thing B responding, stating the number of units still remaining to Thing A, if any.", 
            "title": "Service Delivery APIs"
        }, 
        {
            "location": "/internal-structure/", 
            "text": "What is Worldpay Within and what does it do\n\n\nWorldpay Within is an embeddable payments agent for the Internet of Things (IoT) that can be 'plugged' into your smart device app, enabling it to discover, pay for, and consume the services of other devices. Conversely it also allows your smart device to expose services to consumer devices, receive payments for those services, and then release services to a consumer using the idea of a \nTrusted Trigger\n.\n\n\nIt is all about enabling payments in IoT, allowing smart devices to communicate with each other and exchange value for services.\n\n\nConsumers and producers\n\n\nA consumer (shopper) is a smart device which is looking for services, pays for services and consumes services.\n\n\nA producer (merchant) is a smart device that is able to advertise availability of it's owner services to consumers, take a payment, and release those services to the trusted consumer that made the payment.\n\n\nHow could I use it?\n\n\n\n\nWhat Worldpay Within Does\n\n\nThe above example has a smart car looking for petrol and then paying for the service from the petrol station. The smart car \"wants petrol\", so has HCE (Host Card Emulation; card credentials), making it act as a Shopper. When trying to make a payment, it will connect to Worldpay and request tokenised card credentials based on the smart device it is trying to consume services from.\n\n\nThis token is then securely passed to the petrol pump. In this case the petrol station is the Producer, or is acting as the merchant, or HTE (Host Terminal Emulation, accepting payment), which then directly communicates with the Worldpay gateway to make a 'card on file' or 'eCommerce' payment authorisation request. With the payment authorised, the petrol station then releases the purchased service to the shopper.\n\n\nThe beauty of Worldpay Within is that it enables smart devices to both make and receive payments. In the example above the petrol station could then go on to make payments to the oil company's smart hub which is providing the petrol.\n\n\nHow the Wrapper works\n\n\n\n\nHow the Wrapper Works.\n\n\nOn the left-hand side you have the SDK, on the right-hand side you have the Wrapper, in this case the Java Core. The SDK in Golang has an RPC layer on top which is exposed via Thrift. The Java Core or Wrapper, is built up of the Thrift layer which does the RPC comms to the core SDK. The wrapper also acts as an adapter converting all the data / objects / errors into Pojos that the Java core, or the app you are building can work with.\n\n\nThe important thing to recognise here is that none of the Thrift layer is exposed to you as a developer, and all the RPC calls are handled for you, so essentially you are calling the Worldpay Within seamlessly, managed by the Worldpay Within Wrapper in the appropriate language you are working in.\n\n\nHow the wrapper and SDK work\n\n\n\n\nHow the wrapper and SDK work.\n\n\nThis is another view of the SDK and the app - in this scenario there are two devices with Worldpay Within installed on them that communicate over the internet. One is the 'consumer' and the other is the 'producer', as explained above. As you go down the layers, you have the RPC layer, then the Thrift layer and finally the wrapper layer (above). The wrapper communicates with the SDK via RPC calls. What is not shown is your app will be the next layer shown on the diagram.\n\n\nIn this scenario, the producer is UDP broadcasting a service message, which includes its hostname, IP and UrlPrefix. Once the consumer discovers the broadcast, it is able to communicate over HTTP with the RESTful endpoint on the producer to find out what services it offers. The shopper will then continue the rest of the flow.\n\n\nWhat's happening inside the SDK\n\n\nWe have open sourced the wrappers, example apps, and the Golang SDK. For more information, see \nHome\n.\n\n\nClick \nhere\n for more information about the Worldpay Within architecture.", 
            "title": "Internal structure"
        }, 
        {
            "location": "/internal-structure/#what-is-worldpay-within-and-what-does-it-do", 
            "text": "Worldpay Within is an embeddable payments agent for the Internet of Things (IoT) that can be 'plugged' into your smart device app, enabling it to discover, pay for, and consume the services of other devices. Conversely it also allows your smart device to expose services to consumer devices, receive payments for those services, and then release services to a consumer using the idea of a  Trusted Trigger .  It is all about enabling payments in IoT, allowing smart devices to communicate with each other and exchange value for services.", 
            "title": "What is Worldpay Within and what does it do"
        }, 
        {
            "location": "/internal-structure/#consumers-and-producers", 
            "text": "A consumer (shopper) is a smart device which is looking for services, pays for services and consumes services.  A producer (merchant) is a smart device that is able to advertise availability of it's owner services to consumers, take a payment, and release those services to the trusted consumer that made the payment.", 
            "title": "Consumers and producers"
        }, 
        {
            "location": "/internal-structure/#how-could-i-use-it", 
            "text": "What Worldpay Within Does  The above example has a smart car looking for petrol and then paying for the service from the petrol station. The smart car \"wants petrol\", so has HCE (Host Card Emulation; card credentials), making it act as a Shopper. When trying to make a payment, it will connect to Worldpay and request tokenised card credentials based on the smart device it is trying to consume services from.  This token is then securely passed to the petrol pump. In this case the petrol station is the Producer, or is acting as the merchant, or HTE (Host Terminal Emulation, accepting payment), which then directly communicates with the Worldpay gateway to make a 'card on file' or 'eCommerce' payment authorisation request. With the payment authorised, the petrol station then releases the purchased service to the shopper.  The beauty of Worldpay Within is that it enables smart devices to both make and receive payments. In the example above the petrol station could then go on to make payments to the oil company's smart hub which is providing the petrol.", 
            "title": "How could I use it?"
        }, 
        {
            "location": "/internal-structure/#how-the-wrapper-works", 
            "text": "How the Wrapper Works.  On the left-hand side you have the SDK, on the right-hand side you have the Wrapper, in this case the Java Core. The SDK in Golang has an RPC layer on top which is exposed via Thrift. The Java Core or Wrapper, is built up of the Thrift layer which does the RPC comms to the core SDK. The wrapper also acts as an adapter converting all the data / objects / errors into Pojos that the Java core, or the app you are building can work with.  The important thing to recognise here is that none of the Thrift layer is exposed to you as a developer, and all the RPC calls are handled for you, so essentially you are calling the Worldpay Within seamlessly, managed by the Worldpay Within Wrapper in the appropriate language you are working in.", 
            "title": "How the Wrapper works"
        }, 
        {
            "location": "/internal-structure/#how-the-wrapper-and-sdk-work", 
            "text": "How the wrapper and SDK work.  This is another view of the SDK and the app - in this scenario there are two devices with Worldpay Within installed on them that communicate over the internet. One is the 'consumer' and the other is the 'producer', as explained above. As you go down the layers, you have the RPC layer, then the Thrift layer and finally the wrapper layer (above). The wrapper communicates with the SDK via RPC calls. What is not shown is your app will be the next layer shown on the diagram.  In this scenario, the producer is UDP broadcasting a service message, which includes its hostname, IP and UrlPrefix. Once the consumer discovers the broadcast, it is able to communicate over HTTP with the RESTful endpoint on the producer to find out what services it offers. The shopper will then continue the rest of the flow.", 
            "title": "How the wrapper and SDK work"
        }, 
        {
            "location": "/internal-structure/#whats-happening-inside-the-sdk", 
            "text": "We have open sourced the wrappers, example apps, and the Golang SDK. For more information, see  Home .  Click  here  for more information about the Worldpay Within architecture.", 
            "title": "What's happening inside the SDK"
        }, 
        {
            "location": "/sample-service-messaging/", 
            "text": "Summary\n\n\nThis is an early reference guide which has evolved since it was first published. However, in combination with the SDK code, it should give you plenty of hints as to how to work with the SDK. \n\n\n\n\nService discovery messages\n\n\nWe're going to build a reference application to prove the concepts and APIs outlined above. This reference application will be implemented on the current range of platforms aimed at providing IoT services. These boards are typically running \u2018M\u2019 class processors which as yet do not contain an SE. Currently only the application processors (A class such as A57 Cortex) contain SEs. However developments are being made in the IoT platform space, for example ARM has released a new M architecture with does contain an SE, although there will be delay before boards using these processors and compiler tools become mainstream. This document requires these more secure platforms to be available.\n\n\nService broadcast\n\n\n{\n\n    \nDeviceDescription\n:\n \nWorldpay Within Enabled Electric Car Charger\n,\n\n    \nHostname\n:\n \n[Your hostname]\n,\n\n    \nPortNumber\n:\n \n[\nYour\n \nport\n \nnumber\n],\n\n    \nServerID\n:\n \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\n    \nUrlPrefix\n:\n \nv1/carcharge\n\n\n}\n\n\n\n\n\nService list request\n\n\nIn order to build the URL, use the hostname and the port number, then concatenate the URL with \u201cservice/discover\u201d.\n\n\nhttp://[Your hostname]:[Your port number]/v1/carcharge/service/discover\n\n\n \n{\n\n \n}\n \n\n\n\n\n\n\nNote\n\n\nThe body content is empty; the request is direct to the server, which is indicated in the broadcast.\n\n\n\n\nService list response\n\n\n{\n\n    \nServerID\n:\n \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\n    \nServices\n:\n \n[\n\n        \n{\n\n            \nServiceID\n:\n \n0\n,\n\n            \nServiceDescription\n:\n \nCar charging\n\n        \n},\n\n        \n{\n\n            \nServiceID\n:\n \n1\n,\n\n            \nServiceDescription\n:\n \nCar parking\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\nService negotiation messages\n\n\nService price request\n\n\nIn order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with \u201cservice ID\u201d and then \u201cprices\u201d.\n\n\nhttp://[Your hostname]:[Your port number]/v1/carcharge/service/0/prices\n\n\n{\n\n\n}\n \n\n\n\n\n\n\nNote\n\n\nBody content is empty. URL includes the serviceID (i.e. 0) for the prices being requested, e.g. for serviceID 1, URL would be \n/v1/carcharge/service/1/prices\n)\n\n\n\n\nService price response\n\n\n{\n\n    \nServerID\n \n:\n \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\n    \nPrices\n \n:\n \n[\n\n        \n{\n\n            \nServiceID\n \n:\n \n0\n,\n\n            \nPriceID\n \n:\n \n0\n,\n\n            \nPricePerUnit\n \n:\n \n140\n,\n\n            \nUnitID\n \n:\n \n0\n,\n\n            \nUnitDescription\n \n:\n \nkW\n,\n\n            \nPriceDescription\n \n:\n \nSlow (3.6kWh)\n\n        \n},\n \n{\n\n            \nServiceID\n \n:\n \n0\n,\n\n            \nPriceID\n \n:\n \n1\n,\n\n            \nPricePerUnit\n \n:\n \n70\n,\n\n            \nUnitID\n \n:\n \n0\n,\n\n            \nUnitDescription\n \n:\n \nkW\n,\n\n            \nPriceDescription\n \n:\n \nMedium (7.2kWh)\n\n        \n},\n \n{\n\n            \nServiceID\n \n:\n \n0\n,\n\n            \nPriceID\n \n:\n \n2\n,\n\n            \nPricePerUnit\n \n:\n \n10\n,\n\n            \nUnitID\n \n:\n \n0\n,\n\n            \nUnitDescription\n \n:\n \nkW\n,\n\n            \nPriceDescription\n \n:\n \nSuper (120kWh)\n\n        \n}\n\n    \n]\n\n\n}\n\n\n\n\n\nGet Total price request\n\n\nIn order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with \nservice ID\n and then \nrequestTotal\n.\n\n\nhttp://[Your hostname]:[Your port number]/v1/carcharge/service/0/requestTotal\n\n\n{\n\n    \nClientID\n:\n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nSelectedNumberOfUnits\n:\n8\n,\n\n    \nSelectedPriceID\n:\n1\n\n\n}\n\n\n\n\n\nGet Total price response\n\n\n{\n\n    \nServerID\n:\n \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\n    \nClientID\n:\n \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nPriceID\n:\n \n1\n,\n\n    \nUnitsToSupply\n:\n \n8\n,\n\n    \nTotalPrice\n:\n \n560\n,\n\n    \nPaymentReferenceID\n:\n \ne7c18800-706d-4f0c-933c-19f8d5be72da\n,\n\n    \nMerchantClientKey\n:\n \n T_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx \n\n\n}\n\n\n\n\n\nToken request\n\n\nHTTP POST to:\n\n\nhttps://api.worldpay.com/v1/tokens\n\n\nNo custom HTTP headers used.\n\n\n{\n\n    \nclientKey\n \n:\n \nT_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n,\n\n    \npaymentMethod\n \n:\n \n{\n\n        \ncardNumber\n \n:\n \n1234567890124444\n,\n\n        \nexpiryMonth\n \n:\n \n2\n,\n\n        \nexpiryYear\n \n:\n \n2021\n,\n\n        \nname\n \n:\n \nBilbo Baggins\n,\n\n        \ntype\n \n:\n \nCard\n\n    \n},\n\n    \nreusable\n \n:\n \nfalse\n\n\n}\n\n\n\n\n\nToken response\n\n\n{\n\n    \ntoken\n:\n \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\n,\n\n    \npaymentMethod\n:\n \n{\n\n        \ntype\n:\n \nObfuscatedCard\n,\n\n        \nname\n:\n \nBilbo Baggins\n,\n\n        \nexpiryMonth\n:\n \n2\n,\n\n        \nexpiryYear\n:\n \n2021\n,\n\n        \ncardType\n:\n \nMASTERCARD_CREDIT\n,\n\n        \nmaskedCardNumber\n:\n \n**** **** **** 4444\n,\n\n        \ncardSchemeType\n:\n \nconsumer\n,\n\n        \ncardSchemeName\n:\n \nMCI CREDIT\n,\n\n        \ncardIssuer\n:\n \nLLOYDS BANK PLC\n,\n\n        \ncountryCode\n:\n \nGB\n,\n\n        \ncardClass\n:\n \ncredit\n,\n\n        \ncardProductTypeDescNonContactless\n:\n \nMasterCard Business\n,\n\n        \ncardProductTypeDescContactless\n:\n \nCL MasterCard Bus\n,\n\n        \nprepaid\n:\n \nunknown\n\n        \n},\n\n    \nreusable\n:\n \nfalse\n\n\n}\n\n\n\n\n\nPayment request\n\n\nHTTP POST to:\n\n\nhttp://[Your hostname]:[Your port number]/v1/carcharge/payment\n\n\n{\n\n    \nClientID\n \n:\n \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nClientToken\n \n:\n \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy \n,\n\n    \nPaymentReferenceID\n \n:\n \ne7c18800-706d-4f0c-933c-19f8d5be72da\n\n\n}\n\n\n\n\n\nOrder request\n\n\nHTTP POST to \nhttps://api.worldpay.com/v1/orders\n. \n\n\nHTTP header includes the Merchant's Service Key (Private)\n\n\n{\n\n    \namount\n \n:\n \n560\n,\n\n    \ncurrencyCode\n \n:\n \nGBP\n,\n\n    \ncustomerOrderCode\n \n:\n \nCar charge (8kW @ Medium (7.2kWh)) - 26\\/01\\/2016 15:40\n,\n\n    \norderDescription\n \n:\n \nCar charging payment\n,\n\n    \ntoken\n \n:\n \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy \n\n\n}\n\n\n\n\n\nOrder response\n\n\n{\n\n    \norderCode\n \n:\n \n4d22cb5d-5dfb-43ce-9108-dfe230151429\n,\n\n    \ntoken\n \n:\n \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy \n,\n\n    \norderDescription\n \n:\n \nCar charging payment\n,\n\n    \namount\n \n:\n \n560\n,\n\n    \ncurrencyCode\n \n:\n \nGBP\n,\n\n    \npaymentStatus\n \n:\n \nSUCCESS\n,\n\n    \npaymentResponse\n \n:\n \n{\n\n        \ntype\n \n:\n \nObfuscatedCard\n,\n\n        \nname\n \n:\n \nBilbo Baggins\n,\n\n        \nexpiryMonth\n \n:\n \n2\n,\n\n        \nexpiryYear\n \n:\n \n2021\n,\n\n        \ncardType\n \n:\n \nMASTERCARD_CREDIT\n,\n\n        \nmaskedCardNumber\n \n:\n \n**** **** **** 4444\n,\n\n        \ncardSchemeType\n \n:\n \nconsumer\n,\n\n        \ncardSchemeName\n \n:\n \nMCI CREDIT\n,\n\n        \ncardIssuer\n \n:\n \nLLOYDS BANK PLC\n,\n\n        \ncountryCode\n \n:\n \nGB\n,\n\n        \ncardClass\n \n:\n \ncredit\n,\n\n        \ncardProductTypeDescNonContactless\n \n:\n \nMasterCard Business\n,\n\n        \ncardProductTypeDescContactless\n \n:\n \nCL MasterCard Bus\n,\n\n        \nprepaid\n \n:\n \nunknown\n\n    \n},\n\n    \ncustomerOrderCode\n \n:\n \nCar charge (8kW @ Medium (7.2kWh)) - 26/01/2016 15:40\n,\n\n    \nenvironment\n \n:\n \nTEST\n,\n\n    \nriskScore\n \n:\n \n{\n\n        \nvalue\n \n:\n \n1\n\n    \n}\n\n\n}\n\n\n\n\n\nPayment request response\n\n\n{\n\n    \nServerID\n \n:\n \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\n    \nClientID\n \n:\n \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nTotalPaid\n \n:\n \n0\n,\n\n    \nServiceDeliveryToken\n \n:\n \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n\n    \nclient-uuid\n:\n719D329B-8909-4A8B-B352-E449C3132074\n\n\n}\n\n\n\n\n\nBegin Service Delivery request\n\n\nHTTP POST to \n\n\nhttp://[Your hostname]:[Your port number]/v1/carcharge/service/0/delivery/begin\n\n\nURL encodes the \nserviceID\n being requested\n\n\n{\n\n    \nClientID\n \n:\n \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nServiceDeliveryToken\n \n:\n \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n\n    \nUnitsToSupply\n \n:\n \n8\n\n\n}\n\n\n\n\n\nBegin Service Delivery response content:\n\n\n{\n\n    \nServerID\n \n:\n \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\n    \nClientID\n \n:\n \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nServiceDeliveryToken\n \n:\n \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n\n    \nUnitsToSupply\n \n:\n \n8\n\n\n}\n\n\n\n\n\nEnd Service Delivery request\n\n\nHTTP POST to \n\n\nhttp://[Your hostname]:[Your port number]/v1/carcharge/service/0/delivery/end\n\n\nURL encodes the \nserviceID\n being requested\n\n\n{\n\n    \nClientID\n \n:\n \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nServiceDeliveryToken\n \n:\n \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n\n    \nUnitsReceived\n \n:\n \n8\n\n\n}\n\n\n\n\n\nEnd Service Delivery response content\n\n\n{\n\n    \nServerID\n \n:\n \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\n    \nClientID\n \n:\n \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n\n    \nServiceDeliveryToken\n \n:\n \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n\n    \nUnitsJustSupplied\n \n:\n \n8\n,\n\n    \nUnitsRemaining\n \n:\n \n0\n\n\n}", 
            "title": "Sample service messaging"
        }, 
        {
            "location": "/sample-service-messaging/#service-discovery-messages", 
            "text": "We're going to build a reference application to prove the concepts and APIs outlined above. This reference application will be implemented on the current range of platforms aimed at providing IoT services. These boards are typically running \u2018M\u2019 class processors which as yet do not contain an SE. Currently only the application processors (A class such as A57 Cortex) contain SEs. However developments are being made in the IoT platform space, for example ARM has released a new M architecture with does contain an SE, although there will be delay before boards using these processors and compiler tools become mainstream. This document requires these more secure platforms to be available.", 
            "title": "Service discovery messages"
        }, 
        {
            "location": "/sample-service-messaging/#service-broadcast", 
            "text": "{ \n     DeviceDescription :   Worldpay Within Enabled Electric Car Charger , \n     Hostname :   [Your hostname] , \n     PortNumber :   [ Your   port   number ], \n     ServerID :   58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , \n     UrlPrefix :   v1/carcharge  }", 
            "title": "Service broadcast"
        }, 
        {
            "location": "/sample-service-messaging/#service-list-request", 
            "text": "In order to build the URL, use the hostname and the port number, then concatenate the URL with \u201cservice/discover\u201d.  http://[Your hostname]:[Your port number]/v1/carcharge/service/discover    { \n  }     Note  The body content is empty; the request is direct to the server, which is indicated in the broadcast.", 
            "title": "Service list request"
        }, 
        {
            "location": "/sample-service-messaging/#service-list-response", 
            "text": "{ \n     ServerID :   58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , \n     Services :   [ \n         { \n             ServiceID :   0 , \n             ServiceDescription :   Car charging \n         }, \n         { \n             ServiceID :   1 , \n             ServiceDescription :   Car parking \n         } \n     ]  }", 
            "title": "Service list response"
        }, 
        {
            "location": "/sample-service-messaging/#service-negotiation-messages", 
            "text": "", 
            "title": "Service negotiation messages"
        }, 
        {
            "location": "/sample-service-messaging/#service-price-request", 
            "text": "In order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with \u201cservice ID\u201d and then \u201cprices\u201d.  http://[Your hostname]:[Your port number]/v1/carcharge/service/0/prices  {  }     Note  Body content is empty. URL includes the serviceID (i.e. 0) for the prices being requested, e.g. for serviceID 1, URL would be  /v1/carcharge/service/1/prices )", 
            "title": "Service price request"
        }, 
        {
            "location": "/sample-service-messaging/#service-price-response", 
            "text": "{ \n     ServerID   :   58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , \n     Prices   :   [ \n         { \n             ServiceID   :   0 , \n             PriceID   :   0 , \n             PricePerUnit   :   140 , \n             UnitID   :   0 , \n             UnitDescription   :   kW , \n             PriceDescription   :   Slow (3.6kWh) \n         },   { \n             ServiceID   :   0 , \n             PriceID   :   1 , \n             PricePerUnit   :   70 , \n             UnitID   :   0 , \n             UnitDescription   :   kW , \n             PriceDescription   :   Medium (7.2kWh) \n         },   { \n             ServiceID   :   0 , \n             PriceID   :   2 , \n             PricePerUnit   :   10 , \n             UnitID   :   0 , \n             UnitDescription   :   kW , \n             PriceDescription   :   Super (120kWh) \n         } \n     ]  }", 
            "title": "Service price response"
        }, 
        {
            "location": "/sample-service-messaging/#get-total-price-request", 
            "text": "In order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with  service ID  and then  requestTotal .  http://[Your hostname]:[Your port number]/v1/carcharge/service/0/requestTotal  { \n     ClientID : 54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     SelectedNumberOfUnits : 8 , \n     SelectedPriceID : 1  }", 
            "title": "Get Total price request"
        }, 
        {
            "location": "/sample-service-messaging/#get-total-price-response", 
            "text": "{ \n     ServerID :   58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , \n     ClientID :   54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     PriceID :   1 , \n     UnitsToSupply :   8 , \n     TotalPrice :   560 , \n     PaymentReferenceID :   e7c18800-706d-4f0c-933c-19f8d5be72da , \n     MerchantClientKey :    T_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   }", 
            "title": "Get Total price response"
        }, 
        {
            "location": "/sample-service-messaging/#token-request", 
            "text": "HTTP POST to:  https://api.worldpay.com/v1/tokens  No custom HTTP headers used.  { \n     clientKey   :   T_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx , \n     paymentMethod   :   { \n         cardNumber   :   1234567890124444 , \n         expiryMonth   :   2 , \n         expiryYear   :   2021 , \n         name   :   Bilbo Baggins , \n         type   :   Card \n     }, \n     reusable   :   false  }", 
            "title": "Token request"
        }, 
        {
            "location": "/sample-service-messaging/#token-response", 
            "text": "{ \n     token :   TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy , \n     paymentMethod :   { \n         type :   ObfuscatedCard , \n         name :   Bilbo Baggins , \n         expiryMonth :   2 , \n         expiryYear :   2021 , \n         cardType :   MASTERCARD_CREDIT , \n         maskedCardNumber :   **** **** **** 4444 , \n         cardSchemeType :   consumer , \n         cardSchemeName :   MCI CREDIT , \n         cardIssuer :   LLOYDS BANK PLC , \n         countryCode :   GB , \n         cardClass :   credit , \n         cardProductTypeDescNonContactless :   MasterCard Business , \n         cardProductTypeDescContactless :   CL MasterCard Bus , \n         prepaid :   unknown \n         }, \n     reusable :   false  }", 
            "title": "Token response"
        }, 
        {
            "location": "/sample-service-messaging/#payment-request", 
            "text": "HTTP POST to:  http://[Your hostname]:[Your port number]/v1/carcharge/payment  { \n     ClientID   :   54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     ClientToken   :   TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy  , \n     PaymentReferenceID   :   e7c18800-706d-4f0c-933c-19f8d5be72da  }", 
            "title": "Payment request"
        }, 
        {
            "location": "/sample-service-messaging/#order-request", 
            "text": "HTTP POST to  https://api.worldpay.com/v1/orders .   HTTP header includes the Merchant's Service Key (Private)  { \n     amount   :   560 , \n     currencyCode   :   GBP , \n     customerOrderCode   :   Car charge (8kW @ Medium (7.2kWh)) - 26\\/01\\/2016 15:40 , \n     orderDescription   :   Car charging payment , \n     token   :   TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy   }", 
            "title": "Order request"
        }, 
        {
            "location": "/sample-service-messaging/#order-response", 
            "text": "{ \n     orderCode   :   4d22cb5d-5dfb-43ce-9108-dfe230151429 , \n     token   :   TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy  , \n     orderDescription   :   Car charging payment , \n     amount   :   560 , \n     currencyCode   :   GBP , \n     paymentStatus   :   SUCCESS , \n     paymentResponse   :   { \n         type   :   ObfuscatedCard , \n         name   :   Bilbo Baggins , \n         expiryMonth   :   2 , \n         expiryYear   :   2021 , \n         cardType   :   MASTERCARD_CREDIT , \n         maskedCardNumber   :   **** **** **** 4444 , \n         cardSchemeType   :   consumer , \n         cardSchemeName   :   MCI CREDIT , \n         cardIssuer   :   LLOYDS BANK PLC , \n         countryCode   :   GB , \n         cardClass   :   credit , \n         cardProductTypeDescNonContactless   :   MasterCard Business , \n         cardProductTypeDescContactless   :   CL MasterCard Bus , \n         prepaid   :   unknown \n     }, \n     customerOrderCode   :   Car charge (8kW @ Medium (7.2kWh)) - 26/01/2016 15:40 , \n     environment   :   TEST , \n     riskScore   :   { \n         value   :   1 \n     }  }", 
            "title": "Order response"
        }, 
        {
            "location": "/sample-service-messaging/#payment-request-response", 
            "text": "{ \n     ServerID   :   58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , \n     ClientID   :   54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     TotalPaid   :   0 , \n     ServiceDeliveryToken   :   3e7b4c25-157d-4b47-999c-e4faba086590 , \n     client-uuid : 719D329B-8909-4A8B-B352-E449C3132074  }", 
            "title": "Payment request response"
        }, 
        {
            "location": "/sample-service-messaging/#begin-service-delivery-request", 
            "text": "HTTP POST to   http://[Your hostname]:[Your port number]/v1/carcharge/service/0/delivery/begin  URL encodes the  serviceID  being requested  { \n     ClientID   :   54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     ServiceDeliveryToken   :   3e7b4c25-157d-4b47-999c-e4faba086590 , \n     UnitsToSupply   :   8  }", 
            "title": "Begin Service Delivery request"
        }, 
        {
            "location": "/sample-service-messaging/#begin-service-delivery-response-content", 
            "text": "{ \n     ServerID   :   58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , \n     ClientID   :   54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     ServiceDeliveryToken   :   3e7b4c25-157d-4b47-999c-e4faba086590 , \n     UnitsToSupply   :   8  }", 
            "title": "Begin Service Delivery response content:"
        }, 
        {
            "location": "/sample-service-messaging/#end-service-delivery-request", 
            "text": "HTTP POST to   http://[Your hostname]:[Your port number]/v1/carcharge/service/0/delivery/end  URL encodes the  serviceID  being requested  { \n     ClientID   :   54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     ServiceDeliveryToken   :   3e7b4c25-157d-4b47-999c-e4faba086590 , \n     UnitsReceived   :   8  }", 
            "title": "End Service Delivery request"
        }, 
        {
            "location": "/sample-service-messaging/#end-service-delivery-response-content", 
            "text": "{ \n     ServerID   :   58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , \n     ClientID   :   54560ba2-87c0-4172-a904-67a9b7a5e1ee , \n     ServiceDeliveryToken   :   3e7b4c25-157d-4b47-999c-e4faba086590 , \n     UnitsJustSupplied   :   8 , \n     UnitsRemaining   :   0  }", 
            "title": "End Service Delivery response content"
        }, 
        {
            "location": "/api-spec/", 
            "text": "For the alpha release, we decided to go with five different languages. Their documented API can be found here:\n\n\n\n  \nNode.js\n\n  \nPython\n\n  \nJava\n\n  \n.NET\n\n  \nGo\n\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetup\n\n\nSets up the wrapper to be able to start communicating with the underlying SDK.\n\n\n\n\n\n\naddService\n\n\nAdds a service of type WWService to the producer (merchant). Used if the device you are operating on is a producer. If added to a device you intend as a consumer (shopper), this will give that device producer functionality.\n\n\n\n\n\n\nremoveService\n\n\nRemoves the service from the producer.\n\n\n\n\n\n\ninitConsumer\n\n\nInitiates the device as a consumer, which enables it to find services, choose prices, make payments and receive services.\n\n\n\n\n\n\ninitProducer\n\n\nInitiates the device as a producer / or initialises the producer capability.\n\n\n\n\n\n\ngetDevice\n\n\nProvides details of the the current device that the SDK is running on, and its credentials / information.\n\n\n\n\n\n\nstartServiceBroadcast\n\n\nEnables the producer device to start broadcasting itself via UDP broadcast over the network to notify devices it is available to be consumed.\n\n\n\n\n\n\nstopServiceBroadcast\n\n\nStops the SDK from broadcasting the current service messages that it is broadcasting.\n\n\n\n\n\n\ndeviceDiscovery\n\n\nEnables the consumer device to discover other devices (producers) on the network that are UDP broadcasting.\n\n\n\n\n\n\nrequestServices\n\n\nGets a list of services that are available from the broadcasting device.\n\n\n\n\n\n\ngetServicePrices\n\n\nUsed by the consumer to get the list of prices associated with a particular \nserviceId\n.\n\n\n\n\n\n\nselectService\n\n\nPerformed by the consumer, this provides details of the service, the amount and at what price point it wants to purchase the service.\n\n\n\n\n\n\nmakePayment\n\n\nAllows the consumer to request a payment to be made at the producer device, by providing the total price response object as the request. The producer will then make the payment (or attempt to) and send back a payment response detailing whether it was successful or not.\n\n\n\n\n\n\nbeginServiceDelivery\n\n\nRequested by the consumer, this begins the service delivery which proceeds as long as the correct information is provided to the producer. If the correct credentials are passed, the producer will start releasing the service known as a 'trusted trigger'.\n\n\n\n\n\n\nendServiceDelivery\n\n\nEnds the service delivery - a request initiated by the consumer.", 
            "title": "API Spec"
        }, 
        {
            "location": "/api-spec/#specification", 
            "text": "Parameter  Description      setup  Sets up the wrapper to be able to start communicating with the underlying SDK.    addService  Adds a service of type WWService to the producer (merchant). Used if the device you are operating on is a producer. If added to a device you intend as a consumer (shopper), this will give that device producer functionality.    removeService  Removes the service from the producer.    initConsumer  Initiates the device as a consumer, which enables it to find services, choose prices, make payments and receive services.    initProducer  Initiates the device as a producer / or initialises the producer capability.    getDevice  Provides details of the the current device that the SDK is running on, and its credentials / information.    startServiceBroadcast  Enables the producer device to start broadcasting itself via UDP broadcast over the network to notify devices it is available to be consumed.    stopServiceBroadcast  Stops the SDK from broadcasting the current service messages that it is broadcasting.    deviceDiscovery  Enables the consumer device to discover other devices (producers) on the network that are UDP broadcasting.    requestServices  Gets a list of services that are available from the broadcasting device.    getServicePrices  Used by the consumer to get the list of prices associated with a particular  serviceId .    selectService  Performed by the consumer, this provides details of the service, the amount and at what price point it wants to purchase the service.    makePayment  Allows the consumer to request a payment to be made at the producer device, by providing the total price response object as the request. The producer will then make the payment (or attempt to) and send back a payment response detailing whether it was successful or not.    beginServiceDelivery  Requested by the consumer, this begins the service delivery which proceeds as long as the correct information is provided to the producer. If the correct credentials are passed, the producer will start releasing the service known as a 'trusted trigger'.    endServiceDelivery  Ends the service delivery - a request initiated by the consumer.", 
            "title": "Specification"
        }, 
        {
            "location": "/hackathons/", 
            "text": "Payments \n IoT Hackathons\n\n\nComing soon - November 2017 - Romania hackathon\n\n\nIn November, we're hosting our latest IoT and Payments hackathon, based on Worldpay Within. We're delighted to be hosting this in the beautiful Bucharest, Romania. More details will be coming soon. \n\n\nThis time it's all about Worldpay Within on Raspberry Pis, with the theme focusing on smart home, smart cities and smart living. We've got some really exciting sponsors, which we will also be announcing soon. We've also got really awesome cash prizes for the 3 winning teams. \n\n\nYou'll be able to register for the event soon. If you're super keen and want to hear further ahead of that time, email us at \n.\n\n\nFebruary 2017 - Atlanta hackathon, featuring Worldpay Within\n\n\nWorldpay US was a sponsor of the ATDC Fintech Hackathon, a weekend in which 18 teams competed in a battle to demonstrate how well they integrated either Worldpay or TSYS APIs into their own applications.\n\n\nFor more information, see the \nAtlanta hackathon page\n.\n\n\nSeptember 2016 - Our Inaugral Payments \n Iot hackathon\n\n\nWorldpay's Technology Innovation team held their first Internet of Things (IoT) hackathon at the Impact Hub in Westminster, London. It was the first time they'd hosted a hackathon and it was attended by over 80 technologists and experienced coders, who came together to explore use-cases for exciting mobile payments and new IoT open-source technology.\n\n\nOver the weekend, the participants brought to life a range of innovative concepts from building a payment system following a natural disaster, to payments apps for the sharing economy.\n\n\nSee our press releases \nhere\n and \nhere\n.\n\n\nWatch the video\n\n\nWe recorded what happened at the September 2016 hackathon. You'll hear from some of the delegates, judges, mentors, sponsors and organisers, and see some of the cool tech that was brought and awesome demos that were built that weekend.", 
            "title": "Hackathons"
        }, 
        {
            "location": "/hackathons/#payments-iot-hackathons", 
            "text": "", 
            "title": "Payments &amp; IoT Hackathons"
        }, 
        {
            "location": "/hackathons/#coming-soon-november-2017-romania-hackathon", 
            "text": "In November, we're hosting our latest IoT and Payments hackathon, based on Worldpay Within. We're delighted to be hosting this in the beautiful Bucharest, Romania. More details will be coming soon.   This time it's all about Worldpay Within on Raspberry Pis, with the theme focusing on smart home, smart cities and smart living. We've got some really exciting sponsors, which we will also be announcing soon. We've also got really awesome cash prizes for the 3 winning teams.   You'll be able to register for the event soon. If you're super keen and want to hear further ahead of that time, email us at  .", 
            "title": "Coming soon - November 2017 - Romania hackathon"
        }, 
        {
            "location": "/hackathons/#february-2017-atlanta-hackathon-featuring-worldpay-within", 
            "text": "Worldpay US was a sponsor of the ATDC Fintech Hackathon, a weekend in which 18 teams competed in a battle to demonstrate how well they integrated either Worldpay or TSYS APIs into their own applications.  For more information, see the  Atlanta hackathon page .", 
            "title": "February 2017 - Atlanta hackathon, featuring Worldpay Within"
        }, 
        {
            "location": "/hackathons/#september-2016-our-inaugral-payments-iot-hackathon", 
            "text": "Worldpay's Technology Innovation team held their first Internet of Things (IoT) hackathon at the Impact Hub in Westminster, London. It was the first time they'd hosted a hackathon and it was attended by over 80 technologists and experienced coders, who came together to explore use-cases for exciting mobile payments and new IoT open-source technology.  Over the weekend, the participants brought to life a range of innovative concepts from building a payment system following a natural disaster, to payments apps for the sharing economy.  See our press releases  here  and  here .", 
            "title": "September 2016 - Our Inaugral Payments &amp; Iot hackathon"
        }, 
        {
            "location": "/hackathons/#watch-the-video", 
            "text": "We recorded what happened at the September 2016 hackathon. You'll hear from some of the delegates, judges, mentors, sponsors and organisers, and see some of the cool tech that was brought and awesome demos that were built that weekend.", 
            "title": "Watch the video"
        }, 
        {
            "location": "/atdc/", 
            "text": "Atlanta Fintech Hackathon\n\n\nHere you'll find information about what technology we used during the Atlanta Fintech Hackathon. It includes how to set up your Raspberry Pi, how to see your transactions on Worldpay Total, and how to set up the Python wrapper.\n\n\nSetting up your Pi for Worldpay Within @ ATDC hackathon\n\n\nQuick start\n\n\n\n\nGet a pre-provisioned SD card, which should put you on the 'Connectify' network\n\n\nThe go, and RPi Python wrapper should be ready to go, the RPC agent is available for you to provision the other wrappers too. Speak to Conor or Kevin for help with this\n\n\n\n\nHow to see my transactions on Worldpay Total?\n\n\nDon't get this confused with the Global/European system. For this hackathon you can view the transactions through the virtual terminal here: \nterminal.demo.securenet.com\n - login credentials from Clint.\n\n\nAndroid wrapper?\n\n\nWe have not developed an Android wrapper, however there is one in development on the 'native-interface' branch, which allows you to call into the RPC-agent/SDC by going directly without need for RPC. This partially works, and is not certified, and is on older code, but you are free to experiment with this.\n\n\nIt is probably better to use a 'proxy' Pi as your consumer, and expose each step/feature as a simple RESTful api, which the Android can call to orchestrate the flow. The business logic can then be included in the Android app, with the Worldpay Within SDK running on the Pi. Please discuss with Conor for any more help on this topic.\n\n\nSelf provision the Raspberry Pi\n\n\n\n\nGet the Pi to the provisioning team so they can get it on the Connectify network, or choose Connectify with password: wpt1c123\n\n\nYou should now be able to do the rest yourself, by ssh-ing to the device at \nssh pi@wppi##\n e.g. for the Pi number 40: \nssh pi@wppi40\n\u02dc\u220f\n\n\nChange to the directory with the Worldpay Within SDK in it: \n~/go/src/github.com/wptechinnovation/worldpay-within-sdk/\n\n\nChange to the develop branch \ngit checkout develop\n\n\nPull the latest code \ngit pull\n\n\nGet the latest RPC-agent for Raspberry pi \nwget http://bit.ly/wpwlinarm32\n\n\n\n\nHow to setup the Python 2.7 wrapper\n\n\n\n\nIf you want to use the 2.7 python wrapper, then download apache thrift 0.10.0 (latest version)\n\n\nExtract it and change to the \nlib/py/\n directory\n\n\nRun the following command \nsudo python setup.py install\n\n\nPlace the RPC-agent in the python wrapper directory: \n~/go/src/github.com/wptechinnovation/worldpay-within-sdk/wrappers/python_2-7\n\n\nRename to \nrpc-agent\n, run \nsudo chmod ugo+x rpc-agent\n\n\nTest run it with \n./rpc-agent -port 9018\n, then close it using ctrl-C and make sure it is killed using \nps -e | grep rpc-agent\n and if it's still running do a \nKill \nprocess-id\n\n\nYou're now ready to provision your device with your securenet credentials, and the run the example apps\n\n\n\n\nClick \nhere\n for more information about the Python wrapper.\n\n\nHow to setup the other wrappers\n\n\nIf you want to use the Java, Node.js, Python 3 or .Net wrappers then here is further information about the setup:\n\n\n\n\nJava wrapper - talk to Conor or Kevin, you'll need to setup a project with the source and pull in the libs\n\n\nNode.js\n - or talk to Conor\n\n\nPython 3 - talk to Kevin (HINT: once you've got this wrapper, theres a self contained setup.py)\n\n\n.net wrapper\n - or talk to Conor or Kevin\n\n\n\n\nEnvironment variables for accessing RPC-agent\n\n\nNote that with various support on the wrappers (2.7 python does not yet support), you can use an environment variable for finding your rpc-agent\n\n\nSet the environmental variable \nWPW_HOME\n which is the path to the WPWithin Home. Binaries should go in the $WPW_HOME/bin directory.\n\n\nFor the node.js and Java wrappers, first check if \n$WPW_HOME\n is set. If so, the wrappers launch the appropriately named rpc-agent from \n$WPW_HOME/bin/\n. If not then look for the RPC agent in the \n./rpc-agent-bin/\n directory. E.g. for Mac OS (go with it that it's called amd64...):\n\n\n\n\n$WPW_HOME/bin/rpc-agent-darwin-amd64\n\n\n./rpc-agent-bin/rpc-agent-darwin-amd64\n\n\n\n\nDeploying the Java wrapper to the Pi\n\n\n\n\nAssuming you have the consumer or producer app setup in your favourite IDE\n\n\nDo a clean build of the consumer app to generate a dist directory\n\n\nCreate a \ndistribtopi\n directory\n\n\nCopy the contents of \ndist\n into the \ndistribtopi\n\n\nIn this directory create a subdirectory called \nrpc-agent-bin\n\n\nFrom the latest release, get the Raspberry pi rpc-agent \nrpc-agent-linux-arm32\n\n\nZip up this package and put onto your Pi however you prefer\n\n\nUnzip on the Pi\n\n\nRun the program with \njava -jar \nName-of-your-app\n.jar\n\n\nAny issues you can't debug, come and have a chat with Kevin or Conor we're happy to help\n\n\n\n\nSupport\n\n\nAny issues with setting up Worldpay Within (and the wrappers) on your Raspberry Pi or Development machine please reach out to Conor Hackett or Kevin Gordon, who will be able to support you over this weekend. They've familiar with a few gotchas, and will be able to get you up and running in no time!\n\n\nAlso you can join us on slack here: \nhttps://wpwithin-slack-in.herokuapp.com", 
            "title": "(hidden) Atlanta Fintech Hackathon"
        }, 
        {
            "location": "/atdc/#atlanta-fintech-hackathon", 
            "text": "Here you'll find information about what technology we used during the Atlanta Fintech Hackathon. It includes how to set up your Raspberry Pi, how to see your transactions on Worldpay Total, and how to set up the Python wrapper.", 
            "title": "Atlanta Fintech Hackathon"
        }, 
        {
            "location": "/atdc/#setting-up-your-pi-for-worldpay-within-atdc-hackathon", 
            "text": "", 
            "title": "Setting up your Pi for Worldpay Within @ ATDC hackathon"
        }, 
        {
            "location": "/atdc/#quick-start", 
            "text": "Get a pre-provisioned SD card, which should put you on the 'Connectify' network  The go, and RPi Python wrapper should be ready to go, the RPC agent is available for you to provision the other wrappers too. Speak to Conor or Kevin for help with this", 
            "title": "Quick start"
        }, 
        {
            "location": "/atdc/#how-to-see-my-transactions-on-worldpay-total", 
            "text": "Don't get this confused with the Global/European system. For this hackathon you can view the transactions through the virtual terminal here:  terminal.demo.securenet.com  - login credentials from Clint.", 
            "title": "How to see my transactions on Worldpay Total?"
        }, 
        {
            "location": "/atdc/#android-wrapper", 
            "text": "We have not developed an Android wrapper, however there is one in development on the 'native-interface' branch, which allows you to call into the RPC-agent/SDC by going directly without need for RPC. This partially works, and is not certified, and is on older code, but you are free to experiment with this.  It is probably better to use a 'proxy' Pi as your consumer, and expose each step/feature as a simple RESTful api, which the Android can call to orchestrate the flow. The business logic can then be included in the Android app, with the Worldpay Within SDK running on the Pi. Please discuss with Conor for any more help on this topic.", 
            "title": "Android wrapper?"
        }, 
        {
            "location": "/atdc/#self-provision-the-raspberry-pi", 
            "text": "Get the Pi to the provisioning team so they can get it on the Connectify network, or choose Connectify with password: wpt1c123  You should now be able to do the rest yourself, by ssh-ing to the device at  ssh pi@wppi##  e.g. for the Pi number 40:  ssh pi@wppi40 \u02dc\u220f  Change to the directory with the Worldpay Within SDK in it:  ~/go/src/github.com/wptechinnovation/worldpay-within-sdk/  Change to the develop branch  git checkout develop  Pull the latest code  git pull  Get the latest RPC-agent for Raspberry pi  wget http://bit.ly/wpwlinarm32", 
            "title": "Self provision the Raspberry Pi"
        }, 
        {
            "location": "/atdc/#how-to-setup-the-python-27-wrapper", 
            "text": "If you want to use the 2.7 python wrapper, then download apache thrift 0.10.0 (latest version)  Extract it and change to the  lib/py/  directory  Run the following command  sudo python setup.py install  Place the RPC-agent in the python wrapper directory:  ~/go/src/github.com/wptechinnovation/worldpay-within-sdk/wrappers/python_2-7  Rename to  rpc-agent , run  sudo chmod ugo+x rpc-agent  Test run it with  ./rpc-agent -port 9018 , then close it using ctrl-C and make sure it is killed using  ps -e | grep rpc-agent  and if it's still running do a  Kill  process-id  You're now ready to provision your device with your securenet credentials, and the run the example apps   Click  here  for more information about the Python wrapper.", 
            "title": "How to setup the Python 2.7 wrapper"
        }, 
        {
            "location": "/atdc/#how-to-setup-the-other-wrappers", 
            "text": "If you want to use the Java, Node.js, Python 3 or .Net wrappers then here is further information about the setup:   Java wrapper - talk to Conor or Kevin, you'll need to setup a project with the source and pull in the libs  Node.js  - or talk to Conor  Python 3 - talk to Kevin (HINT: once you've got this wrapper, theres a self contained setup.py)  .net wrapper  - or talk to Conor or Kevin", 
            "title": "How to setup the other wrappers"
        }, 
        {
            "location": "/atdc/#environment-variables-for-accessing-rpc-agent", 
            "text": "Note that with various support on the wrappers (2.7 python does not yet support), you can use an environment variable for finding your rpc-agent  Set the environmental variable  WPW_HOME  which is the path to the WPWithin Home. Binaries should go in the $WPW_HOME/bin directory.  For the node.js and Java wrappers, first check if  $WPW_HOME  is set. If so, the wrappers launch the appropriately named rpc-agent from  $WPW_HOME/bin/ . If not then look for the RPC agent in the  ./rpc-agent-bin/  directory. E.g. for Mac OS (go with it that it's called amd64...):   $WPW_HOME/bin/rpc-agent-darwin-amd64  ./rpc-agent-bin/rpc-agent-darwin-amd64", 
            "title": "Environment variables for accessing RPC-agent"
        }, 
        {
            "location": "/atdc/#deploying-the-java-wrapper-to-the-pi", 
            "text": "Assuming you have the consumer or producer app setup in your favourite IDE  Do a clean build of the consumer app to generate a dist directory  Create a  distribtopi  directory  Copy the contents of  dist  into the  distribtopi  In this directory create a subdirectory called  rpc-agent-bin  From the latest release, get the Raspberry pi rpc-agent  rpc-agent-linux-arm32  Zip up this package and put onto your Pi however you prefer  Unzip on the Pi  Run the program with  java -jar  Name-of-your-app .jar  Any issues you can't debug, come and have a chat with Kevin or Conor we're happy to help", 
            "title": "Deploying the Java wrapper to the Pi"
        }, 
        {
            "location": "/atdc/#support", 
            "text": "Any issues with setting up Worldpay Within (and the wrappers) on your Raspberry Pi or Development machine please reach out to Conor Hackett or Kevin Gordon, who will be able to support you over this weekend. They've familiar with a few gotchas, and will be able to get you up and running in no time!  Also you can join us on slack here:  https://wpwithin-slack-in.herokuapp.com", 
            "title": "Support"
        }
    ]
}